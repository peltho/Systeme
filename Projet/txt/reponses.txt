Question 2a
===========

Les deux instructions permettent de réserver la mémoire d'un processus.
STMEM seulement pour le processus courant (utilisable en mode utilisateur)
Avec STPRM on peut réserver la mémoire de n'importe quel processus (à utiliser en mode maître)
LDPSW : il suffit pour le noayu, de faire ldpsw d'un proc P,
pour se brancher sur le code de P ; car cette instruction permet de charger l'état du processus quand il a été arrêté,
dans le cadre d'un changement de contexte notamment.

Question 2b
===========

SETRI R0 0         ; stocke la valeur 0 dans R0
LDMEM R0 R1        ; charge R0 dans R1 pour obtenir le PID du processus à arreter
SETRI R2 20        ; stocke la valeur 20 dans R2
ADDRG R0 R1 R2     ; stocke R1 + R2 (0 + 20) dans R0 pour obtenir l'@ du processus
SETRI R3 0         ; stocke la valeur 0 dans R3, qui correspondra à son état
STMEM R0 R3        ; stocke 0 à R0, donc à l'@ du processus, ce qui a pour effet de le terminer
JMBSI $int1        ; on retourne à int1 pour élire un nouveau processus

Question 2c
===========

Chaque processus contient divers registres tels que spReg, pcReg, mdReg, prReg qui sont stockés dans la mémoire.
Ces registres sont stockés à différents endroits de la mémoire selon que l'opération effectuée sur le processus soit le chargement de celui-ci,
ou bien sa sauvegarde dans la tranche mémoire du noyau.

Question 2d
===========

La ligne 168 de Proc_0_Program.asm sert à stocker la valeur 0 dans la sémaphore pour obtenir V()

Les sémaphores sont binaires, pour passer en mode V(), il faut lui faire prendre la valeur 0.
Pour passer en mode P(), il faut lui passer la valeur 1.

Question 2e
===========

La tranche mémoire du noyau contient plusieurs adresses, notamment KERNELSAVECURRENTPROCID qui contient l'adresse du processus courant sauvegardé.
Il y a également le vecteur d'interruptions, les tables d'état des processus
et le vecteur d'adresses de début des vecteurs de requêtes de semop par processsus.
Y sont également stockés les items (leur type, nombre, etc.) // à développer

Question 2f
===========

9 processus maximum
9 semops

Questions 3
===========

Explication d'int5
------------------

###############
### log.txt ###
###############

300 0 1 304 404 65 0 0 0 0 0 // Ligne 4743 de log.txt
400 0 0 0 0 1 0 0 0 0 0      // La valeur 1 est à @404 et correspond au type de l'item (0:int ou 1:char)

300 : @ ds la mémoire du noyau
0   : valeur (input ou ->output)                // @300
1   : nombre d'items                            // @301
304 : @ de l'item                               // @302 \ Contiennent une valeur
404 : @ du type de l'item                       // @303 / correspondant à une @
65  : valeur ASCII de l'item qui est un char    // @304

##########################
### Proc_0_Program.asm ###
##########################

# R2 : nombre d'items
# R3 : @ du premier item
# R4 : @ du type pour un item

#...
SETRI R7 301       ; on stocke la valeur 301 (qui sera une @) dans R7
STMEM R7 R5        ; on stocke la valeur 1 à R7, donc à l'@301
LDPRM R1 R3 R6     ; on charge R3 (@ du premier item) du processus R1 dans R6
SETRI R8 304       ; on stocke la valeur 304 (qui sera une @) dans R8
STMEM R8 R6        ; on stocke la valeur de l'item à R6, donc à l'@304
SETRI R7 302       ; on stocke la valeur 302 (qui sera une @) dans R7
STMEM R7 R8        ; on stocke la valeur 304 à R7, donc à l'@302
LDPRM R1 R4 R7     ; on charge R4 (@ du type de l'item) du processus R1 pour récupérer la valeur du type (0:int/1:char) qu'on stocke dans R7
SETRI R8 404       ; on stocke la valeur 404 (qui sera une @) dans R8 (qui contenait la valeur '304')
STMEM R8 R7        ; on stocke le type de l'item à R8, donc à l'@404
SETRI R7 303       ; on stocke la valeur 303 (qui sera une @) dans R7
STMEM R7 R8        ; on stocke le type de l'item à R7, donc à l'@303
SETRI R7 300       ; on stocke la valeur 300 (qui sera une @) dans R7
STMEM R7 R5        ; on stocke la valeur 1 à R7, donc à l'@300 ce qui déclenche un consoleInOut.output()
JMBSI $int1        ; on retourne à int1


Question 3b
===========

Ecriture d'int6
---------------

# ...
SETRI R9 0         ; on stocke la valeur 0 (qui déclenchera input()) dans R
SETRI R7 301       ; on stocke la valeur 301 (qui sera une @) dans R7
STMEM R7 R9        ; on stocke la valeur 1 à R7, donc à l'@301

# ...              ; Faut-il garder la même chose que fait précédemment dans int5 au même endroit ?

SETRI R7 300       ; on stocke la valeur 300 (qui sera une @) dans R7
STMEM R7 R9        ; on stocke la valeur 0 à R7, donc à l'@300 ce qui déclenche un consoleInOut.input()
JMBSI $int1        ; on retourne à int1