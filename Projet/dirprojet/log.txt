4BaseCPU::BaseCPU() complete for M
CPU::CPU() complete for M
ProgramCounter::fetch() line 0
CPU(M)::execute() pr 0 JMBSI 129        ;0  absolute jump to $prep: to prepare the memory structure (intvec, proc/file tables) zero, PC = 129
 PR = 0 SP = 999 PC = 129 MD = 1 qI = 0
ProgramCounter::fetch() line 129
CPU(M)::execute() pr 0 SETRI R0 1         ;129=$prep: initial kernel setup, R0 constant increment/decrement value R0 = 1
 PR = 0 SP = 999 PC = 130 MD = 1 qI = 0
ProgramCounter::fetch() line 130
CPU(M)::execute() pr 0 SETRI R1 1         ;130 address of first slot in the interrupt vector R1 = 1
 PR = 0 SP = 999 PC = 131 MD = 1 qI = 0
ProgramCounter::fetch() line 131
CPU(M)::execute() pr 0 SETRI R2 1     ;131 prog address of $int1 start next available process R2 = 1
 PR = 0 SP = 999 PC = 132 MD = 1 qI = 0
ProgramCounter::fetch() line 132
CPU(M)::execute() pr 0 STMEM R1 R2        ;132 setting up the interrupt vector for interrupt #1 R2 = 1 to addr 1
 PR = 0 SP = 999 PC = 133 MD = 1 qI = 0
ProgramCounter::fetch() line 133
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;133 increment the address of slots R1 = 2
 PR = 0 SP = 999 PC = 134 MD = 1 qI = 0
ProgramCounter::fetch() line 134
CPU(M)::execute() pr 0 SETRI R2 53     ;134 prog address of $int2: exit current process R2 = 53
 PR = 0 SP = 999 PC = 135 MD = 1 qI = 0
ProgramCounter::fetch() line 135
CPU(M)::execute() pr 0 STMEM R1 R2        ;135 setting up the interrupt vector for interrupt #2 R2 = 53 to addr 2
 PR = 0 SP = 999 PC = 136 MD = 1 qI = 0
ProgramCounter::fetch() line 136
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;136 increment the address of slots R1 = 3
 PR = 0 SP = 999 PC = 137 MD = 1 qI = 0
ProgramCounter::fetch() line 137
CPU(M)::execute() pr 0 SETRI R2 60     ;137 prog address of $int3: scheduler interrupt R2 = 60
 PR = 0 SP = 999 PC = 138 MD = 1 qI = 0
ProgramCounter::fetch() line 138
CPU(M)::execute() pr 0 STMEM R1 R2        ;138 setting up the interrupt vector for interrupt #3 R2 = 60 to addr 3
 PR = 0 SP = 999 PC = 139 MD = 1 qI = 0
ProgramCounter::fetch() line 139
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;139 increment the address of slots R1 = 4
 PR = 0 SP = 999 PC = 140 MD = 1 qI = 0
ProgramCounter::fetch() line 140
CPU(M)::execute() pr 0 SETRI R2 67     ;140 prog address of $int4: semop Request R2 = 67
 PR = 0 SP = 999 PC = 141 MD = 1 qI = 0
ProgramCounter::fetch() line 141
CPU(M)::execute() pr 0 STMEM R1 R2        ;141 setting up the interrupt vector for interrupt #3 R2 = 67 to addr 4
 PR = 0 SP = 999 PC = 142 MD = 1 qI = 0
ProgramCounter::fetch() line 142
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;142 increment the address of slots R1 = 5
 PR = 0 SP = 999 PC = 143 MD = 1 qI = 0
ProgramCounter::fetch() line 143
CPU(M)::execute() pr 0 SETRI R2 106     ;143 address of $int5: consoleOut Request R2 = 106
 PR = 0 SP = 999 PC = 144 MD = 1 qI = 0
ProgramCounter::fetch() line 144
CPU(M)::execute() pr 0 STMEM R1 R2        ;144 setting up the interrupt vector for interrupt #4 R2 = 106 to addr 5
 PR = 0 SP = 999 PC = 145 MD = 1 qI = 0
ProgramCounter::fetch() line 145
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;145 increment the address of slots R1 = 6
 PR = 0 SP = 999 PC = 146 MD = 1 qI = 0
ProgramCounter::fetch() line 146
CPU(M)::execute() pr 0 SETRI R2 127     ;146 address of $int6: consoleIn Request R2 = 127
 PR = 0 SP = 999 PC = 147 MD = 1 qI = 0
ProgramCounter::fetch() line 147
CPU(M)::execute() pr 0 STMEM R1 R2        ;147 setting up the interrupt vector for interrupt #5 R2 = 127 to addr 6
 PR = 0 SP = 999 PC = 148 MD = 1 qI = 0
ProgramCounter::fetch() line 148
CPU(M)::execute() pr 0 SETRI R1 21        ;148 address where process table starts R1 = 21
 PR = 0 SP = 999 PC = 149 MD = 1 qI = 0
ProgramCounter::fetch() line 149
CPU(M)::execute() pr 0 SETRI R2 1         ;149 ReadyToRun initial procstate value R2 = 1
 PR = 0 SP = 999 PC = 150 MD = 1 qI = 0
ProgramCounter::fetch() line 150
CPU(M)::execute() pr 0 GETI0 R3           ;150 number of processes R3 = 3
 PR = 0 SP = 999 PC = 151 MD = 1 qI = 0
ProgramCounter::fetch() line 151
CPU(M)::execute() pr 0 SETRI R8 20        ;151 address to save the number of processes R8 = 20
 PR = 0 SP = 999 PC = 152 MD = 1 qI = 0
ProgramCounter::fetch() line 152
CPU(M)::execute() pr 0 STMEM R8 R3        ;152 saving the number of processes R3 = 3 to addr 20
 PR = 0 SP = 999 PC = 153 MD = 1 qI = 0
ProgramCounter::fetch() line 153
CPU(M)::execute() pr 0 ADDRG R9 R8 R0	   ;153 offset for the semwaitlists R9 = 21
 PR = 0 SP = 999 PC = 154 MD = 1 qI = 0
ProgramCounter::fetch() line 154
CPU(M)::execute() pr 0 SETRI R10 200	   ;154 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R10 = 200
 PR = 0 SP = 999 PC = 155 MD = 1 qI = 0
ProgramCounter::fetch() line 155
CPU(M)::execute() pr 0 ADDRG R7 R10 R8    ;155 the first such address  R7 = 220
 PR = 0 SP = 999 PC = 156 MD = 1 qI = 0
ProgramCounter::fetch() line 156
CPU(M)::execute() pr 0 STMEM R1 R2        ;156=$procSetup: set initial process state value to current slot R2 = 1 to addr 21
 PR = 0 SP = 999 PC = 157 MD = 1 qI = 0
ProgramCounter::fetch() line 157
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;157 advance address for process table slot R1 = 22
 PR = 0 SP = 999 PC = 158 MD = 1 qI = 0
ProgramCounter::fetch() line 158
CPU(M)::execute() pr 0 STMEM R10 R7	   ;158 setting the start address for the current proc sem waitlists in the master proc sem waitlists address vect R7 = 220 to addr 200
 PR = 0 SP = 999 PC = 159 MD = 1 qI = 0
ProgramCounter::fetch() line 159
CPU(M)::execute() pr 0 ADDRG R7 R7 R9	   ;159 increment the start address with the right offset R7 = 241
 PR = 0 SP = 999 PC = 160 MD = 1 qI = 0
ProgramCounter::fetch() line 160
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;160 advance address in the master proc sem waitlists address vect R10 = 201
 PR = 0 SP = 999 PC = 161 MD = 1 qI = 0
ProgramCounter::fetch() line 161
CPU(M)::execute() pr 0 SUBRG R3 R3 R0     ;161 decrement loop counter R3 = 2
 PR = 0 SP = 999 PC = 162 MD = 1 qI = 0
ProgramCounter::fetch() line 162
CPU(M)::execute() pr 0 JNZRI R3 -7 ;162 jump back to $procSetup: for max number processes non zero, PC = 156
 PR = 0 SP = 999 PC = 156 MD = 1 qI = 0
ProgramCounter::fetch() line 156
CPU(M)::execute() pr 0 STMEM R1 R2        ;156=$procSetup: set initial process state value to current slot R2 = 1 to addr 22
 PR = 0 SP = 999 PC = 157 MD = 1 qI = 0
ProgramCounter::fetch() line 157
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;157 advance address for process table slot R1 = 23
 PR = 0 SP = 999 PC = 158 MD = 1 qI = 0
ProgramCounter::fetch() line 158
CPU(M)::execute() pr 0 STMEM R10 R7	   ;158 setting the start address for the current proc sem waitlists in the master proc sem waitlists address vect R7 = 241 to addr 201
 PR = 0 SP = 999 PC = 159 MD = 1 qI = 0
ProgramCounter::fetch() line 159
CPU(M)::execute() pr 0 ADDRG R7 R7 R9	   ;159 increment the start address with the right offset R7 = 262
 PR = 0 SP = 999 PC = 160 MD = 1 qI = 0
ProgramCounter::fetch() line 160
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;160 advance address in the master proc sem waitlists address vect R10 = 202
 PR = 0 SP = 999 PC = 161 MD = 1 qI = 0
ProgramCounter::fetch() line 161
CPU(M)::execute() pr 0 SUBRG R3 R3 R0     ;161 decrement loop counter R3 = 1
 PR = 0 SP = 999 PC = 162 MD = 1 qI = 0
ProgramCounter::fetch() line 162
CPU(M)::execute() pr 0 JNZRI R3 -7 ;162 jump back to $procSetup: for max number processes non zero, PC = 156
 PR = 0 SP = 999 PC = 156 MD = 1 qI = 0
ProgramCounter::fetch() line 156
CPU(M)::execute() pr 0 STMEM R1 R2        ;156=$procSetup: set initial process state value to current slot R2 = 1 to addr 23
 PR = 0 SP = 999 PC = 157 MD = 1 qI = 0
ProgramCounter::fetch() line 157
CPU(M)::execute() pr 0 ADDRG R1 R1 R0     ;157 advance address for process table slot R1 = 24
 PR = 0 SP = 999 PC = 158 MD = 1 qI = 0
ProgramCounter::fetch() line 158
CPU(M)::execute() pr 0 STMEM R10 R7	   ;158 setting the start address for the current proc sem waitlists in the master proc sem waitlists address vect R7 = 262 to addr 202
 PR = 0 SP = 999 PC = 159 MD = 1 qI = 0
ProgramCounter::fetch() line 159
CPU(M)::execute() pr 0 ADDRG R7 R7 R9	   ;159 increment the start address with the right offset R7 = 283
 PR = 0 SP = 999 PC = 160 MD = 1 qI = 0
ProgramCounter::fetch() line 160
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;160 advance address in the master proc sem waitlists address vect R10 = 203
 PR = 0 SP = 999 PC = 161 MD = 1 qI = 0
ProgramCounter::fetch() line 161
CPU(M)::execute() pr 0 SUBRG R3 R3 R0     ;161 decrement loop counter R3 = 0
 PR = 0 SP = 999 PC = 162 MD = 1 qI = 0
ProgramCounter::fetch() line 162
CPU(M)::execute() pr 0 JNZRI R3 -7 ;162 jump back to $procSetup: for max number processes zero, PC = 163
 PR = 0 SP = 999 PC = 163 MD = 1 qI = 0
ProgramCounter::fetch() line 163
CPU(M)::execute() pr 0 SETRI R0 0         ;163 address where current scheduled proc id is stored R0 = 0
 PR = 0 SP = 999 PC = 164 MD = 1 qI = 0
ProgramCounter::fetch() line 164
CPU(M)::execute() pr 0 SETRI R1 0	   ;164 pid 0 R1 = 0
 PR = 0 SP = 999 PC = 165 MD = 1 qI = 0
ProgramCounter::fetch() line 165
CPU(M)::execute() pr 0 STMEM R0 R1	   ;165 just to initialize the state of the system for int1  R1 = 0 to addr 0
 PR = 0 SP = 999 PC = 166 MD = 1 qI = 0
ProgramCounter::fetch() line 166
CPU(M)::execute() pr 0 JMBSI 1        ;166 absolute jump to $int1: to start the work    , @@end of initial kernel setup@@ zero, PC = 1
 PR = 0 SP = 999 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 999 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 0 from addr 0
 PR = 0 SP = 999 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 999 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 1
 PR = 0 SP = 999 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 999 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 999 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 999 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 999 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 999 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 999 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 999 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 999 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 1
 PR = 0 SP = 999 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -3
 PR = 0 SP = 999 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 999 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 999 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 21
 PR = 0 SP = 999 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 999 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 201
 PR = 0 SP = 999 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 21
 PR = 0 SP = 999 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 999 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 999 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 999 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 999 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 999 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 999 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 21
 PR = 0 SP = 999 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 999 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 999 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 1 SP = 1000 PC = 0 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 0 R3 = 0 R4 = 0 R5 = 0 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 0 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 0
CPU(M)::execute() pr 1 SETRI R0 0	  ; index of first (and unique) semaphore  R0 = 0
 PR = 1 SP = 1000 PC = 1 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 1 SETRI R2 1	  ; code of P(), and also count of semop()s R2 = 1
 PR = 1 SP = 1000 PC = 2 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 1 SETRI R3 210	  ; address for the P() semop R3 = 210
 PR = 1 SP = 1000 PC = 3 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 1 STMEM R3 R0	  ; store the index of the semaphore to operate on R0 = 0 to addr 210
 PR = 1 SP = 1000 PC = 4 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 1 ADDRG R3 R3 R2	  ; advance the address R3 = 211
 PR = 1 SP = 1000 PC = 5 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 1 STMEM R3 R2	  ; store the P() operation code R2 = 1 to addr 211
 PR = 1 SP = 1000 PC = 6 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 1 SETRI R3 220	  ; address for the V() semop R3 = 220
 PR = 1 SP = 1000 PC = 7 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 1 STMEM R3 R0	  ; store the index of the semaphore to operate on R0 = 0 to addr 220
 PR = 1 SP = 1000 PC = 8 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 1 ADDRG R3 R3 R2    ; advance the address R3 = 221
 PR = 1 SP = 1000 PC = 9 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 1 STMEM R3 R0       ; store the V() operation code R0 = 0 to addr 221
 PR = 1 SP = 1000 PC = 10 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 1 SETRI R5 10	  ; shared memory address (agreed upon with the other proc) R5 = 10
 PR = 1 SP = 1000 PC = 11 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 1 SETRI R4 4	  ; int number for semop() request, that is int4  R4 = 4
 PR = 1 SP = 1000 PC = 12 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 1 SETRI R3 210	  ; waitLoop , set address for the P() semop R3 = 210
 PR = 1 SP = 1000 PC = 13 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 1 CLINT R4	  ; P() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 210 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 210 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 211
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 1 from addr 211 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 1 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 212
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 1 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = 0
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 1 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = 0
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op zero, PC = 187
 PR = 0 SP = 999 PC = 187 MD = 1 qI = 0
ProgramCounter::fetch() line 187
CPU(M)::execute() pr 0 STMEM R18 R16      ;187 ok, do P() on the semaphore (which was in state V) -- R18 had the address of the current semaphore  R16 = 1 to addr 100
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 210 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 1 LDSHM R5 R6	  ; read the shared memory value R6 = 0 from addr 10
 PR = 1 SP = 1000 PC = 15 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 1 SETRI R3 220	  ; set address for the V() semop R3 = 220
 PR = 1 SP = 1000 PC = 16 MD = 0 qI = 1
Kernel scheduler interrupt.
M Interrupt #3  PR = 0 SP = 1000 PC = 60 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
Not interrupted this time.
ProgramCounter::fetch() line 60
CPU(M)::execute() pr 0 SETRI R0 0         ;60=$int3: scheduler interrupt, the current process , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 61 MD = 1 qI = 0
ProgramCounter::fetch() line 61
CPU(M)::execute() pr 0 LDMEM R0 R1        ;61 R1 now has the pid of the process which was just interrupted R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 62 MD = 1 qI = 0
ProgramCounter::fetch() line 62
CPU(M)::execute() pr 0 SETRI R2 20        ;62 offset to get the process slot address from the process id R2 = 20
 PR = 0 SP = 1000 PC = 63 MD = 1 qI = 0
ProgramCounter::fetch() line 63
CPU(M)::execute() pr 0 ADDRG R0 R1 R2     ;63 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 64 MD = 1 qI = 0
ProgramCounter::fetch() line 64
CPU(M)::execute() pr 0 SETRI R3 1         ;64 the interrupted process new state value of readyToRun R3 = 1
 PR = 0 SP = 1000 PC = 65 MD = 1 qI = 0
ProgramCounter::fetch() line 65
CPU(M)::execute() pr 0 STMEM R0 R3        ;65 set the state of the process to readyToRun R3 = 1 to addr 21
 PR = 0 SP = 1000 PC = 66 MD = 1 qI = 0
ProgramCounter::fetch() line 66
CPU(M)::execute() pr 0 JMBSI 1        ;66 absolute jump to $int1: to keep going    , @@end of interrupt #3@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 1 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 2
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 2
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -2
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 22
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 202
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 22
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 22
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 2 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 2 SP = 1000 PC = 0 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 0 R3 = 0 R4 = 0 R5 = 0 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 2 SP = 1000 PC = 0 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 0
CPU(M)::execute() pr 2 SETRI R0 0	  ; index of first (and unique) semaphore  R0 = 0
 PR = 2 SP = 1000 PC = 1 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 2 SETRI R2 1	  ; code of P(), and also count of semop()s R2 = 1
 PR = 2 SP = 1000 PC = 2 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 2 SETRI R3 215	  ; address for the P() semop R3 = 215
 PR = 2 SP = 1000 PC = 3 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 2 STMEM R3 R0	  ; store the index of the semaphore to operate on R0 = 0 to addr 215
 PR = 2 SP = 1000 PC = 4 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 2 ADDRG R3 R3 R2	  ; advance the address R3 = 216
 PR = 2 SP = 1000 PC = 5 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 2 STMEM R3 R2	  ; store the P() operation code R2 = 1 to addr 216
 PR = 2 SP = 1000 PC = 6 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 2 SETRI R3 225	  ; address for the V() semop R3 = 225
 PR = 2 SP = 1000 PC = 7 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 2 STMEM R3 R0	  ; store the index of the semaphore to operate on R0 = 0 to addr 225
 PR = 2 SP = 1000 PC = 8 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 2 ADDRG R3 R3 R2    ; advance the address R3 = 226
 PR = 2 SP = 1000 PC = 9 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 2 STMEM R3 R0       ; store the V() operation code R0 = 0 to addr 226
 PR = 2 SP = 1000 PC = 10 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 2 SETRI R5 10	  ; shared memory address (agreed upon with the other proc) R5 = 10
 PR = 2 SP = 1000 PC = 11 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 2 SETRI R4 4	  ; int number for semop() request, that is int4 R4 = 4
 PR = 2 SP = 1000 PC = 12 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 2 SETRI R6 65	  ; value to write in shared memory R6 = 65
 PR = 2 SP = 1000 PC = 13 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 2 SETRI R3 215	  ; set address for the P() semop R3 = 215
 PR = 2 SP = 1000 PC = 14 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 2 CLINT R4	  ; P() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 215 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 2 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 22
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 22
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 202
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 262 from addr 202
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 262
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 263
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 215 of proc 2
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 263
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 216
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 264
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 1 from addr 216 of proc 2
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 1 to addr 264
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 217
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 262 from addr 202
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 262
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 263
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 263
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 1 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = 0
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 264
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 1 from addr 264
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = 0
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state zero, PC = 181
 PR = 0 SP = 999 PC = 181 MD = 1 qI = 0
ProgramCounter::fetch() line 181
CPU(M)::execute() pr 0 JNZRI R21 9 ;181 ok, the current semaphore is in P , now, jump to $maybeDoVonSemP: if the current semop code is V() zero, PC = 182
 PR = 0 SP = 999 PC = 182 MD = 1 qI = 0
ProgramCounter::fetch() line 182
CPU(M)::execute() pr 0 SETRI R16 0        ;182 actually the current semop is P(), (and the current semaphore is in P) so we cannot do anything , we return with 0 in R16  R16 = 0
 PR = 0 SP = 999 PC = 183 MD = 1 qI = 0
ProgramCounter::fetch() line 183
CPU(M)::execute() pr 0 SETRI R17 1        ;183 the stack frame width -- we know its only 1 R17 = 1
 PR = 0 SP = 999 PC = 184 MD = 1 qI = 0
ProgramCounter::fetch() line 184
CPU(M)::execute() pr 0 RETSB R17          ;184 for any RETSB we need the R17=1 for the stack frame width PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 2 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 3
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 3
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -1
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 23
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 203
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 23
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 23
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 3 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 3 SP = 1000 PC = 0 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 0 R3 = 0 R4 = 0 R5 = 0 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 3 SP = 1000 PC = 0 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 0
CPU(M)::execute() pr 3 SETRI R3 350     R3 = 350
 PR = 3 SP = 1000 PC = 1 MD = 0 qI = 1
Kernel scheduler interrupt.
M Interrupt #3  PR = 0 SP = 1000 PC = 60 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 0 R3 = 350 R4 = 0 R5 = 0 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
Not interrupted this time.
ProgramCounter::fetch() line 60
CPU(M)::execute() pr 0 SETRI R0 0         ;60=$int3: scheduler interrupt, the current process , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 61 MD = 1 qI = 0
ProgramCounter::fetch() line 61
CPU(M)::execute() pr 0 LDMEM R0 R1        ;61 R1 now has the pid of the process which was just interrupted R1 = 3 from addr 0
 PR = 0 SP = 1000 PC = 62 MD = 1 qI = 0
ProgramCounter::fetch() line 62
CPU(M)::execute() pr 0 SETRI R2 20        ;62 offset to get the process slot address from the process id R2 = 20
 PR = 0 SP = 1000 PC = 63 MD = 1 qI = 0
ProgramCounter::fetch() line 63
CPU(M)::execute() pr 0 ADDRG R0 R1 R2     ;63 R0 now contains the process slot address R0 = 23
 PR = 0 SP = 1000 PC = 64 MD = 1 qI = 0
ProgramCounter::fetch() line 64
CPU(M)::execute() pr 0 SETRI R3 1         ;64 the interrupted process new state value of readyToRun R3 = 1
 PR = 0 SP = 1000 PC = 65 MD = 1 qI = 0
ProgramCounter::fetch() line 65
CPU(M)::execute() pr 0 STMEM R0 R3        ;65 set the state of the process to readyToRun R3 = 1 to addr 23
 PR = 0 SP = 1000 PC = 66 MD = 1 qI = 0
ProgramCounter::fetch() line 66
CPU(M)::execute() pr 0 JMBSI 1        ;66 absolute jump to $int1: to keep going    , @@end of interrupt #3@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 3 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 4
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 4
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = 0
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue zero, PC = 16
 PR = 0 SP = 1000 PC = 16 MD = 1 qI = 0
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 0 SETRI R0 1	   ;16 otherwise, we need to set R0 to 1 to wrap around (pid zero is for the kernel) R0 = 1
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 21
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 201
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 21
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 21
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 1 SP = 1000 PC = 16 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 16 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 1 CLINT R4	  ; V() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 1 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = 0
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state zero, PC = 181
 PR = 0 SP = 999 PC = 181 MD = 1 qI = 0
ProgramCounter::fetch() line 181
CPU(M)::execute() pr 0 JNZRI R21 9 ;181 ok, the current semaphore is in P , now, jump to $maybeDoVonSemP: if the current semop code is V() non zero, PC = 191
 PR = 0 SP = 999 PC = 191 MD = 1 qI = 0
ProgramCounter::fetch() line 191
CPU(M)::execute() pr 0 JZROI R13 -4 ;191=$maybeDoVonSemP: actually jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 1 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = 0
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state zero, PC = 181
 PR = 0 SP = 999 PC = 181 MD = 1 qI = 0
ProgramCounter::fetch() line 181
CPU(M)::execute() pr 0 JNZRI R21 9 ;181 ok, the current semaphore is in P , now, jump to $maybeDoVonSemP: if the current semop code is V() non zero, PC = 191
 PR = 0 SP = 999 PC = 191 MD = 1 qI = 0
ProgramCounter::fetch() line 191
CPU(M)::execute() pr 0 JZROI R13 -4 ;191=$maybeDoVonSemP: actually jump to $nextsem if we only need to examine and not also do it non zero, PC = 192
 PR = 0 SP = 999 PC = 192 MD = 1 qI = 0
ProgramCounter::fetch() line 192
CPU(M)::execute() pr 0 STMEM R18 R27      ;192 ok, do V() on the semaphore (which was in state P) -- R18 had the address of the current semaphore  R27 = 0 to addr 100
 PR = 0 SP = 999 PC = 193 MD = 1 qI = 0
ProgramCounter::fetch() line 193
CPU(M)::execute() pr 0 JMTOI -6     ;193 jump to $nextsem: zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 1 JZROI R6 -5	  ; jump back to waitLoop if the value read from shmem is zero zero, PC = 13
 PR = 1 SP = 1000 PC = 13 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 1 CLINT R4	  ; P() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 1 LDSHM R5 R6	  ; read the shared memory value R6 = 0 from addr 10
 PR = 1 SP = 1000 PC = 15 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 1 SETRI R3 220	  ; set address for the V() semop R3 = 220
 PR = 1 SP = 1000 PC = 16 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 1 CLINT R4	  ; V() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 1 JZROI R6 -5	  ; jump back to waitLoop if the value read from shmem is zero zero, PC = 13
 PR = 1 SP = 1000 PC = 13 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 1 CLINT R4	  ; P() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 1 LDSHM R5 R6	  ; read the shared memory value R6 = 0 from addr 10
 PR = 1 SP = 1000 PC = 15 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 1 SETRI R3 220	  ; set address for the V() semop R3 = 220
 PR = 1 SP = 1000 PC = 16 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 1 CLINT R4	  ; V() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 1 JZROI R6 -5	  ; jump back to waitLoop if the value read from shmem is zero zero, PC = 13
 PR = 1 SP = 1000 PC = 13 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 1 CLINT R4	  ; P() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 1 LDSHM R5 R6	  ; read the shared memory value R6 = 0 from addr 10
 PR = 1 SP = 1000 PC = 15 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 1 SETRI R3 220	  ; set address for the V() semop R3 = 220
 PR = 1 SP = 1000 PC = 16 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 1 CLINT R4	  ; V() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1
Kernel scheduler interrupt.
M Interrupt #3  PR = 0 SP = 1000 PC = 60 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
Not interrupted this time.
ProgramCounter::fetch() line 60
CPU(M)::execute() pr 0 SETRI R0 0         ;60=$int3: scheduler interrupt, the current process , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 61 MD = 1 qI = 0
ProgramCounter::fetch() line 61
CPU(M)::execute() pr 0 LDMEM R0 R1        ;61 R1 now has the pid of the process which was just interrupted R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 62 MD = 1 qI = 0
ProgramCounter::fetch() line 62
CPU(M)::execute() pr 0 SETRI R2 20        ;62 offset to get the process slot address from the process id R2 = 20
 PR = 0 SP = 1000 PC = 63 MD = 1 qI = 0
ProgramCounter::fetch() line 63
CPU(M)::execute() pr 0 ADDRG R0 R1 R2     ;63 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 64 MD = 1 qI = 0
ProgramCounter::fetch() line 64
CPU(M)::execute() pr 0 SETRI R3 1         ;64 the interrupted process new state value of readyToRun R3 = 1
 PR = 0 SP = 1000 PC = 65 MD = 1 qI = 0
ProgramCounter::fetch() line 65
CPU(M)::execute() pr 0 STMEM R0 R3        ;65 set the state of the process to readyToRun R3 = 1 to addr 21
 PR = 0 SP = 1000 PC = 66 MD = 1 qI = 0
ProgramCounter::fetch() line 66
CPU(M)::execute() pr 0 JMBSI 1        ;66 absolute jump to $int1: to keep going    , @@end of interrupt #3@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 1 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 2
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 2
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -2
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 22
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 202
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 3 from addr 22
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 3
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 2
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready non zero, PC = 27
 PR = 0 SP = 1000 PC = 27 MD = 1 qI = 0
ProgramCounter::fetch() line 27
CPU(M)::execute() pr 0 SUBRG R12 R12 R4   ;27 prepare the test whether this process is in semwait R12 = 0
 PR = 0 SP = 1000 PC = 28 MD = 1 qI = 0
ProgramCounter::fetch() line 28
CPU(M)::execute() pr 0 JNZRI R12 11 ;28 jump to $nextproc: since the proc of id R0 is not in semwait zero, PC = 29
 PR = 0 SP = 1000 PC = 29 MD = 1 qI = 0
ProgramCounter::fetch() line 29
CPU(M)::execute() pr 0 SETRI R13 0        ;29 ok, this proc is in semwait, preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 30 MD = 1 qI = 0
ProgramCounter::fetch() line 30
CPU(M)::execute() pr 0 SETRI R5 1         ;30 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 31 MD = 1 qI = 0
ProgramCounter::fetch() line 31
CPU(M)::execute() pr 0 SETRI R16 169 ;31 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 32 MD = 1 qI = 0
ProgramCounter::fetch() line 32
CPU(M)::execute() pr 0 CLLSB R5 R16       ;32 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 262 from addr 202
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 262
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 263
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 263
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 264
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 1 from addr 264
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = 0
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 33
 PR = 0 SP = 1000 PC = 33 MD = 1 qI = 0
ProgramCounter::fetch() line 33
CPU(M)::execute() pr 0 JZROI R16 6 ;33  because it means we still cannot apply the semops this proc was waiting for non zero, PC = 34
 PR = 0 SP = 1000 PC = 34 MD = 1 qI = 0
ProgramCounter::fetch() line 34
CPU(M)::execute() pr 0 SETRI R13 1        ;34 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 35 MD = 1 qI = 0
ProgramCounter::fetch() line 35
CPU(M)::execute() pr 0 SETRI R5 1         ;35 the frame width for the subroutine call R5 = 1
 PR = 0 SP = 1000 PC = 36 MD = 1 qI = 0
ProgramCounter::fetch() line 36
CPU(M)::execute() pr 0 SETRI R16 169 ;36 the address of the start of the $semoptest sub     R16 = 169
 PR = 0 SP = 1000 PC = 37 MD = 1 qI = 0
ProgramCounter::fetch() line 37
CPU(M)::execute() pr 0 CLLSB R5 R16       ;37 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 262 from addr 202
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 262
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 263
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 263
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 264
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 1 from addr 264
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = 0
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op zero, PC = 187
 PR = 0 SP = 999 PC = 187 MD = 1 qI = 0
ProgramCounter::fetch() line 187
CPU(M)::execute() pr 0 STMEM R18 R16      ;187 ok, do P() on the semaphore (which was in state V) -- R18 had the address of the current semaphore  R16 = 1 to addr 100
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 38
 PR = 0 SP = 1000 PC = 38 MD = 1 qI = 0
ProgramCounter::fetch() line 38
CPU(M)::execute() pr 0 JZROI R16 128   ;38 this should never ever happen non zero, PC = 39
 PR = 0 SP = 1000 PC = 39 MD = 1 qI = 0
ProgramCounter::fetch() line 39
CPU(M)::execute() pr 0 JMTOI 8   ;39 jump to $startproc: we are now done with all the semaphore operations, and can complete the election of process of pid R0 zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 22
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 2 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 2 SP = 1000 PC = 15 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 215 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 2 SP = 1000 PC = 15 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 2 STSHM R5 R6	  ; store the value in the shared memory R6 = 65 to addr 10
 PR = 2 SP = 1000 PC = 16 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 2 SETRI R3 225	  ; set address for the V() semop R3 = 225
 PR = 2 SP = 1000 PC = 17 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 2 CLINT R4	  ; V() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 225 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 2 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 22
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 22
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 202
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 262 from addr 202
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 262
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 263
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 225 of proc 2
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 263
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 226
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 264
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 226 of proc 2
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 264
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 227
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 262 from addr 202
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 262
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 263
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 263
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 1 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = 0
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 264
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 264
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state zero, PC = 181
 PR = 0 SP = 999 PC = 181 MD = 1 qI = 0
ProgramCounter::fetch() line 181
CPU(M)::execute() pr 0 JNZRI R21 9 ;181 ok, the current semaphore is in P , now, jump to $maybeDoVonSemP: if the current semop code is V() non zero, PC = 191
 PR = 0 SP = 999 PC = 191 MD = 1 qI = 0
ProgramCounter::fetch() line 191
CPU(M)::execute() pr 0 JZROI R13 -4 ;191=$maybeDoVonSemP: actually jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 262 from addr 202
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 262
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 263
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 263
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 1 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = 0
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 264
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 264
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state zero, PC = 181
 PR = 0 SP = 999 PC = 181 MD = 1 qI = 0
ProgramCounter::fetch() line 181
CPU(M)::execute() pr 0 JNZRI R21 9 ;181 ok, the current semaphore is in P , now, jump to $maybeDoVonSemP: if the current semop code is V() non zero, PC = 191
 PR = 0 SP = 999 PC = 191 MD = 1 qI = 0
ProgramCounter::fetch() line 191
CPU(M)::execute() pr 0 JZROI R13 -4 ;191=$maybeDoVonSemP: actually jump to $nextsem if we only need to examine and not also do it non zero, PC = 192
 PR = 0 SP = 999 PC = 192 MD = 1 qI = 0
ProgramCounter::fetch() line 192
CPU(M)::execute() pr 0 STMEM R18 R27      ;192 ok, do V() on the semaphore (which was in state P) -- R18 had the address of the current semaphore  R27 = 0 to addr 100
 PR = 0 SP = 999 PC = 193 MD = 1 qI = 0
ProgramCounter::fetch() line 193
CPU(M)::execute() pr 0 JMTOI -6     ;193 jump to $nextsem: zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 22
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 2
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 2 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 2 SP = 1000 PC = 18 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 225 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 2 SP = 1000 PC = 18 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 2 SETRI R9 2        ; int number for exit()  R9 = 2
 PR = 2 SP = 1000 PC = 19 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 2 CLINT R9          ; kernel int2 exits the process PR = 0 SP = 1000 PC = 53 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 225 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 2 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 53 MD = 1 qI = 0
ProgramCounter::fetch() line 53
CPU(M)::execute() pr 0 SETRI R0 0         ;53=$int2: exit current process    , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 54 MD = 1 qI = 0
ProgramCounter::fetch() line 54
CPU(M)::execute() pr 0 LDMEM R0 R1        ;54 R1 now has the pid of the process which is now exiting R1 = 2 from addr 0
 PR = 0 SP = 1000 PC = 55 MD = 1 qI = 0
ProgramCounter::fetch() line 55
CPU(M)::execute() pr 0 SETRI R2 20        ;55 offset to get the process slot address from the process id R2 = 20
 PR = 0 SP = 1000 PC = 56 MD = 1 qI = 0
ProgramCounter::fetch() line 56
CPU(M)::execute() pr 0 ADDRG R0 R1 R2     ;56 R0 now contains the process slot address R0 = 22
 PR = 0 SP = 1000 PC = 57 MD = 1 qI = 0
ProgramCounter::fetch() line 57
CPU(M)::execute() pr 0 SETRI R3 0         ;57 the exited process state value R3 = 0
 PR = 0 SP = 1000 PC = 58 MD = 1 qI = 0
ProgramCounter::fetch() line 58
CPU(M)::execute() pr 0 STMEM R0 R3        ;58 set the state of the process to exit R3 = 0 to addr 22
 PR = 0 SP = 1000 PC = 59 MD = 1 qI = 0
ProgramCounter::fetch() line 59
CPU(M)::execute() pr 0 JMBSI 1        ;59 absolute jump to $int1: to keep going    , @@end of interrupt #2@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 2 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 3
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 3
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -1
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 23
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 203
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 23
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 23
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 3 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 3 SP = 1000 PC = 1 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 0 R3 = 350 R4 = 0 R5 = 0 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 3 SP = 1000 PC = 1 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 3 SETRI R1 20 R1 = 20
 PR = 3 SP = 1000 PC = 2 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 3 STMEM R3 R1 R1 = 20 to addr 350
 PR = 3 SP = 1000 PC = 3 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 3 SETRI R4 380 R4 = 380
 PR = 3 SP = 1000 PC = 4 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 3 SETRI R1 0 R1 = 0
 PR = 3 SP = 1000 PC = 5 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 3 STMEM R4 R1 R1 = 0 to addr 380
 PR = 3 SP = 1000 PC = 6 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 3 SETRI R2 1 R2 = 1
 PR = 3 SP = 1000 PC = 7 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 3 SETRI R0 5 R0 = 5
 PR = 3 SP = 1000 PC = 8 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 3 CLINT R0        ; kernel int5 consoleOut PR = 0 SP = 1000 PC = 106 MD = 1 qI = 0 R0 = 5 R1 = 0 R2 = 1 R3 = 350 R4 = 380 R5 = 0 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 106 MD = 1 qI = 0
ProgramCounter::fetch() line 106
CPU(M)::execute() pr 0 SETRI R0 0         ;106=$int5: consoleOut request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 107 MD = 1 qI = 0
ProgramCounter::fetch() line 107
CPU(M)::execute() pr 0 LDMEM R0 R1        ;107 R1 now has the pid of the process which is requesting the consoleOut operation R1 = 3 from addr 0
 PR = 0 SP = 1000 PC = 108 MD = 1 qI = 0
ProgramCounter::fetch() line 108
CPU(M)::execute() pr 0 SETRI R6 20	   ;108 offset to get the process slot address from the process id R6 = 20
 PR = 0 SP = 1000 PC = 109 MD = 1 qI = 0
ProgramCounter::fetch() line 109
CPU(M)::execute() pr 0 ADDRG R0 R1 R6	   ;109 R0 now contains the process slot address R0 = 23
 PR = 0 SP = 1000 PC = 110 MD = 1 qI = 0
ProgramCounter::fetch() line 110
CPU(M)::execute() pr 0 SETRI R5 1	   ;110 the readyToRun state R5 = 1
 PR = 0 SP = 1000 PC = 111 MD = 1 qI = 0
ProgramCounter::fetch() line 111
CPU(M)::execute() pr 0 STMEM R0 R5	   ;111 store the readyToRun state for the current process R5 = 1 to addr 23
 PR = 0 SP = 1000 PC = 112 MD = 1 qI = 0
ProgramCounter::fetch() line 112
CPU(M)::execute() pr 0 SETRI R7 301	   ;112 The address in kernel memory where we need to write the # of items for the consoleOut R7 = 301
 PR = 0 SP = 1000 PC = 113 MD = 1 qI = 0
ProgramCounter::fetch() line 113
CPU(M)::execute() pr 0 STMEM R7 R5        ;113 just one item for now R5 = 1 to addr 301
 PR = 0 SP = 1000 PC = 114 MD = 1 qI = 0
ProgramCounter::fetch() line 114
CPU(M)::execute() pr 0 LDPRM R1 R3 R6     ;114 R6 now contains the first item to be obtained (read) and thus sent to consoleOut (recall R3 is given to us by the proc) CPU(M)::execute() pr 0 LDPRM R1 R3 R6     ;114 R6 now contains the first item to be obtained (read) and thus sent to consoleOut (recall R3 is given to us by the proc) R6 = 20 from addr 350 of proc 3
 PR = 0 SP = 1000 PC = 115 MD = 1 qI = 0
ProgramCounter::fetch() line 115
CPU(M)::execute() pr 0 SETRI R8 304	   ;115 The address in kernel memory where we decided to write the item (copying it from the process memory) R8 = 304
 PR = 0 SP = 1000 PC = 116 MD = 1 qI = 0
ProgramCounter::fetch() line 116
CPU(M)::execute() pr 0 STMEM R8 R6 	   ;116 now writing the item (from R6) which we just read from the process memory a few lines above, at address 304 in kernel mem R6 = 20 to addr 304
 PR = 0 SP = 1000 PC = 117 MD = 1 qI = 0
ProgramCounter::fetch() line 117
CPU(M)::execute() pr 0 SETRI R7 302	   ;117 The address in kernel memory where we need to write the start address (param) where to read the items for the consoleOut R7 = 302
 PR = 0 SP = 1000 PC = 118 MD = 1 qI = 0
ProgramCounter::fetch() line 118
CPU(M)::execute() pr 0 STMEM R7 R8	   ;118 now effectively preparing the start address "parameter" for consoleOut (i.e. write the number '304' at address 302) R8 = 304 to addr 302
 PR = 0 SP = 1000 PC = 119 MD = 1 qI = 0
ProgramCounter::fetch() line 119
CPU(M)::execute() pr 0 LDPRM R1 R4 R7     ;119 R7 now contains the type of first item to be obtained (read) and thus sent to consoleOut CPU(M)::execute() pr 0 LDPRM R1 R4 R7     ;119 R7 now contains the type of first item to be obtained (read) and thus sent to consoleOut R7 = 0 from addr 380 of proc 3
 PR = 0 SP = 1000 PC = 120 MD = 1 qI = 0
ProgramCounter::fetch() line 120
CPU(M)::execute() pr 0 SETRI R8 404	   ;120 The address in kernel memory where we decided to write the item (copying it from the process memory) R8 = 404
 PR = 0 SP = 1000 PC = 121 MD = 1 qI = 0
ProgramCounter::fetch() line 121
CPU(M)::execute() pr 0 STMEM R8 R7 	   ;121 now writing the item type (from R7) which we just read from the process memory a few lines above, at address 404 in kernel mem R7 = 0 to addr 404
 PR = 0 SP = 1000 PC = 122 MD = 1 qI = 0
ProgramCounter::fetch() line 122
CPU(M)::execute() pr 0 SETRI R7 303	   ;122 The address in kernel memory where we need to write the start address (param) where to read the item types for the consoleOut R7 = 303
 PR = 0 SP = 1000 PC = 123 MD = 1 qI = 0
ProgramCounter::fetch() line 123
CPU(M)::execute() pr 0 STMEM R7 R8	   ;123 now effectively preparing the type vect start address "parameter" for consoleOut (i.e. write the number '404' at address 303) R8 = 404 to addr 303
 PR = 0 SP = 1000 PC = 124 MD = 1 qI = 0
ProgramCounter::fetch() line 124
CPU(M)::execute() pr 0 SETRI R7 300	   ;124 The address in kernel memory where, by writing a value of 1, we trigger the consoleOut R7 = 300
 PR = 0 SP = 1000 PC = 125 MD = 1 qI = 0
ProgramCounter::fetch() line 125
ConsoleOutput for 1 items:
20
ConsoleOutput end
 PR = 0 SP = 1000 PC = 126 MD = 1 qI = 0
ProgramCounter::fetch() line 126
CPU(M)::execute() pr 0 JMBSI 1        ;126 we are done, so we make an absolute jump to $int1: to keep going , @@end of interrupt #5@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 3 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 4
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 4
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = 0
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue zero, PC = 16
 PR = 0 SP = 1000 PC = 16 MD = 1 qI = 0
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 0 SETRI R0 1	   ;16 otherwise, we need to set R0 to 1 to wrap around (pid zero is for the kernel) R0 = 1
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 21
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 201
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 21
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 21
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 1 JZROI R6 -5	  ; jump back to waitLoop if the value read from shmem is zero zero, PC = 13
 PR = 1 SP = 1000 PC = 13 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 1 CLINT R4	  ; P() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 14 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 1 LDSHM R5 R6	  ; read the shared memory value R6 = 65 from addr 10
 PR = 1 SP = 1000 PC = 15 MD = 0 qI = 1
Kernel scheduler interrupt.
M Interrupt #3  PR = 0 SP = 1000 PC = 60 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
Not interrupted this time.
ProgramCounter::fetch() line 60
CPU(M)::execute() pr 0 SETRI R0 0         ;60=$int3: scheduler interrupt, the current process , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 61 MD = 1 qI = 0
ProgramCounter::fetch() line 61
CPU(M)::execute() pr 0 LDMEM R0 R1        ;61 R1 now has the pid of the process which was just interrupted R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 62 MD = 1 qI = 0
ProgramCounter::fetch() line 62
CPU(M)::execute() pr 0 SETRI R2 20        ;62 offset to get the process slot address from the process id R2 = 20
 PR = 0 SP = 1000 PC = 63 MD = 1 qI = 0
ProgramCounter::fetch() line 63
CPU(M)::execute() pr 0 ADDRG R0 R1 R2     ;63 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 64 MD = 1 qI = 0
ProgramCounter::fetch() line 64
CPU(M)::execute() pr 0 SETRI R3 1         ;64 the interrupted process new state value of readyToRun R3 = 1
 PR = 0 SP = 1000 PC = 65 MD = 1 qI = 0
ProgramCounter::fetch() line 65
CPU(M)::execute() pr 0 STMEM R0 R3        ;65 set the state of the process to readyToRun R3 = 1 to addr 21
 PR = 0 SP = 1000 PC = 66 MD = 1 qI = 0
ProgramCounter::fetch() line 66
CPU(M)::execute() pr 0 JMBSI 1        ;66 absolute jump to $int1: to keep going    , @@end of interrupt #3@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 1 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 2
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 2
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -2
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 22
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 202
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 0 from addr 22
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: zero, PC = 40
 PR = 0 SP = 1000 PC = 40 MD = 1 qI = 0
ProgramCounter::fetch() line 40
CPU(M)::execute() pr 0 ADDRG R0 R0 R2     ;40=$nextproc: increment the pid for the next process to study  R0 = 3
 PR = 0 SP = 1000 PC = 41 MD = 1 qI = 0
ProgramCounter::fetch() line 41
CPU(M)::execute() pr 0 SUBRG R1 R1 R2     ;41 decrement loop counter R1 = 2
 PR = 0 SP = 1000 PC = 42 MD = 1 qI = 0
ProgramCounter::fetch() line 42
CPU(M)::execute() pr 0 JNZRI R1  -30     ;42 jump to $top: loop for max number processes non zero, PC = 13
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 3
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -1
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 23
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 203
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 23
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 23
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 3 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 3 SP = 1000 PC = 9 MD = 0 qI = 1 R0 = 5 R1 = 0 R2 = 1 R3 = 350 R4 = 380 R5 = 0 R6 = 0 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 3 SP = 1000 PC = 9 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 3 SETRI R6 2 R6 = 2
 PR = 3 SP = 1000 PC = 10 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 3 CLINT R6        ; kernel int2 exits the process PR = 0 SP = 1000 PC = 53 MD = 1 qI = 0 R0 = 5 R1 = 0 R2 = 1 R3 = 350 R4 = 380 R5 = 0 R6 = 2 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 53 MD = 1 qI = 0
ProgramCounter::fetch() line 53
CPU(M)::execute() pr 0 SETRI R0 0         ;53=$int2: exit current process    , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 54 MD = 1 qI = 0
ProgramCounter::fetch() line 54
CPU(M)::execute() pr 0 LDMEM R0 R1        ;54 R1 now has the pid of the process which is now exiting R1 = 3 from addr 0
 PR = 0 SP = 1000 PC = 55 MD = 1 qI = 0
ProgramCounter::fetch() line 55
CPU(M)::execute() pr 0 SETRI R2 20        ;55 offset to get the process slot address from the process id R2 = 20
 PR = 0 SP = 1000 PC = 56 MD = 1 qI = 0
ProgramCounter::fetch() line 56
CPU(M)::execute() pr 0 ADDRG R0 R1 R2     ;56 R0 now contains the process slot address R0 = 23
 PR = 0 SP = 1000 PC = 57 MD = 1 qI = 0
ProgramCounter::fetch() line 57
CPU(M)::execute() pr 0 SETRI R3 0         ;57 the exited process state value R3 = 0
 PR = 0 SP = 1000 PC = 58 MD = 1 qI = 0
ProgramCounter::fetch() line 58
CPU(M)::execute() pr 0 STMEM R0 R3        ;58 set the state of the process to exit R3 = 0 to addr 23
 PR = 0 SP = 1000 PC = 59 MD = 1 qI = 0
ProgramCounter::fetch() line 59
CPU(M)::execute() pr 0 JMBSI 1        ;59 absolute jump to $int1: to keep going    , @@end of interrupt #2@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 3 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 4
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 4
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = 0
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue zero, PC = 16
 PR = 0 SP = 1000 PC = 16 MD = 1 qI = 0
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 0 SETRI R0 1	   ;16 otherwise, we need to set R0 to 1 to wrap around (pid zero is for the kernel) R0 = 1
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 21
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 201
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 21
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 21
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 1 SP = 1000 PC = 15 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 15 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 1 SETRI R3 220	  ; set address for the V() semop R3 = 220
 PR = 1 SP = 1000 PC = 16 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 1 CLINT R4	  ; V() the semaphore PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 67 MD = 1 qI = 0
ProgramCounter::fetch() line 67
CPU(M)::execute() pr 0 SETRI R0 0         ;67=$int4: semop request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 68 MD = 1 qI = 0
ProgramCounter::fetch() line 68
CPU(M)::execute() pr 0 LDMEM R0 R1        ;68 R1 now has the pid of the process which is requesting a semop R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 69 MD = 1 qI = 0
ProgramCounter::fetch() line 69
CPU(M)::execute() pr 0 SETRI R4 20        ;69 offset to get the process slot address from the process id R4 = 20
 PR = 0 SP = 1000 PC = 70 MD = 1 qI = 0
ProgramCounter::fetch() line 70
CPU(M)::execute() pr 0 ADDRG R0 R1 R4     ;70 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 71 MD = 1 qI = 0
ProgramCounter::fetch() line 71
CPU(M)::execute() pr 0 SETRI R6 3         ;71 the SemWait state value R6 = 3
 PR = 0 SP = 1000 PC = 72 MD = 1 qI = 0
ProgramCounter::fetch() line 72
CPU(M)::execute() pr 0 STMEM R0 R6        ;72 change the process state to SemWait (address in R0) R6 = 3 to addr 21
 PR = 0 SP = 1000 PC = 73 MD = 1 qI = 0
ProgramCounter::fetch() line 73
CPU(M)::execute() pr 0 SETRI R14 200      ;73 the start of the proc sem waitlists address vect, one for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 74 MD = 1 qI = 0
ProgramCounter::fetch() line 74
CPU(M)::execute() pr 0 ADDRG R14 R14 R1   ;74 the start of the current proc sem waitlist address vect R14 = 201
 PR = 0 SP = 1000 PC = 75 MD = 1 qI = 0
ProgramCounter::fetch() line 75
CPU(M)::execute() pr 0 LDMEM R14 R5	   ;75 now R5 contains the first address of the proc sem waitlists vect in kernel memory R5 = 241 from addr 201
 PR = 0 SP = 1000 PC = 76 MD = 1 qI = 0
ProgramCounter::fetch() line 76
CPU(M)::execute() pr 0 STMEM R5 R2	   ;76 first we store the length, then we're going to go one by one to copy the R2 elements, starting with the first R2 = 1 to addr 241
 PR = 0 SP = 1000 PC = 77 MD = 1 qI = 0
ProgramCounter::fetch() line 77
CPU(M)::execute() pr 0 SETRI R7 1	   ;77 constant increment R7 = 1
 PR = 0 SP = 1000 PC = 78 MD = 1 qI = 0
ProgramCounter::fetch() line 78
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;78=$semwcopy: advance R5 to the address of the first component of the current element of the proc sem waitlists  R5 = 242
 PR = 0 SP = 1000 PC = 79 MD = 1 qI = 0
ProgramCounter::fetch() line 79
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;79 read the first component of the first semop from process memory R8 = 0 from addr 220 of proc 1
 PR = 0 SP = 1000 PC = 80 MD = 1 qI = 0
ProgramCounter::fetch() line 80
CPU(M)::execute() pr 0 STMEM R5 R8	   ;80 store the first component of the first semop in kernel memory R8 = 0 to addr 242
 PR = 0 SP = 1000 PC = 81 MD = 1 qI = 0
ProgramCounter::fetch() line 81
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;81 advance R3 to the address of the second component of the current semop of the proc sem waitlists in proc memory R3 = 221
 PR = 0 SP = 1000 PC = 82 MD = 1 qI = 0
ProgramCounter::fetch() line 82
CPU(M)::execute() pr 0 ADDRG R5 R5 R7	   ;82 advance R5 to the address of the second component of the current semop of the proc sem waitlists in kernel memory R5 = 243
 PR = 0 SP = 1000 PC = 83 MD = 1 qI = 0
ProgramCounter::fetch() line 83
CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory CPU(M)::execute() pr 0 LDPRM R1 R3 R8	   ;83 read the second component of the current semop from process memory R8 = 0 from addr 221 of proc 1
 PR = 0 SP = 1000 PC = 84 MD = 1 qI = 0
ProgramCounter::fetch() line 84
CPU(M)::execute() pr 0 STMEM R5 R8	   ;84 store the second component of the current semop in kernel memory R8 = 0 to addr 243
 PR = 0 SP = 1000 PC = 85 MD = 1 qI = 0
ProgramCounter::fetch() line 85
CPU(M)::execute() pr 0 ADDRG R3 R3 R7	   ;85 advance R3 to the address of the first component of the next semop (if any) of the proc sem waitlists in proc memory R3 = 222
 PR = 0 SP = 1000 PC = 86 MD = 1 qI = 0
ProgramCounter::fetch() line 86
CPU(M)::execute() pr 0 SUBRG R2 R2 R7	   ;86 decrement the loop counter R2 = 0
 PR = 0 SP = 1000 PC = 87 MD = 1 qI = 0
ProgramCounter::fetch() line 87
CPU(M)::execute() pr 0 JNZRI R2 -10 ;87 loop back to continue copying until done zero, PC = 88
 PR = 0 SP = 1000 PC = 88 MD = 1 qI = 0
ProgramCounter::fetch() line 88
CPU(M)::execute() pr 0 SETRI R15 100      ;88 done, so now preparing the start address of the semaphore vector (where we keep the semaphore state values)   R15 = 100
 PR = 0 SP = 1000 PC = 89 MD = 1 qI = 0
ProgramCounter::fetch() line 89
CPU(M)::execute() pr 0 SETRI R13 0        ;89 preparing for semoptest(0): we are first only testing R13 = 0
 PR = 0 SP = 1000 PC = 90 MD = 1 qI = 0
ProgramCounter::fetch() line 90
CPU(M)::execute() pr 0 SETRI R5 1         ;90 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 91 MD = 1 qI = 0
ProgramCounter::fetch() line 91
CPU(M)::execute() pr 0 SETRI R16 169 ;91 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 92 MD = 1 qI = 0
ProgramCounter::fetch() line 92
CPU(M)::execute() pr 0 CLLSB R5 R16       ;92 call to $semoptest(R13=0, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 93
 PR = 0 SP = 1000 PC = 93 MD = 1 qI = 0
ProgramCounter::fetch() line 93
CPU(M)::execute() pr 0 JZROI R16 -93    ;93 because it means we cannot apply the semops, so we need to elect another process , the current one will remain in SemWait for now non zero, PC = 94
 PR = 0 SP = 1000 PC = 94 MD = 1 qI = 0
ProgramCounter::fetch() line 94
CPU(M)::execute() pr 0 SETRI R13 1        ;94 ok, ready to apply them  R13 = 1
 PR = 0 SP = 1000 PC = 95 MD = 1 qI = 0
ProgramCounter::fetch() line 95
CPU(M)::execute() pr 0 SETRI R5 1         ;95 the frame width for the subroutine call  R5 = 1
 PR = 0 SP = 1000 PC = 96 MD = 1 qI = 0
ProgramCounter::fetch() line 96
CPU(M)::execute() pr 0 SETRI R16 169 ;96 the address of the start of the $semoptest sub R16 = 169
 PR = 0 SP = 1000 PC = 97 MD = 1 qI = 0
ProgramCounter::fetch() line 97
CPU(M)::execute() pr 0 CLLSB R5 R16       ;97 call to $semoptest(R13=1, R14=current proc semlist address, R15=semvect addr) PC = 169
 PR = 0 SP = 999 PC = 169 MD = 1 qI = 0
ProgramCounter::fetch() line 169
CPU(M)::execute() pr 0 SETRI R16 1        ;169=$semoptest: can we indeed P() each sem we were waiting for ? (the V()'s will go through anyway) R16 = 1
 PR = 0 SP = 999 PC = 170 MD = 1 qI = 0
ProgramCounter::fetch() line 170
CPU(M)::execute() pr 0 LDMEM R14 R22      ;170 R22 now contains the address where the current proc semwaitlist really starts R22 = 241 from addr 201
 PR = 0 SP = 999 PC = 171 MD = 1 qI = 0
ProgramCounter::fetch() line 171
CPU(M)::execute() pr 0 LDMEM R22 R17      ;171 R17 contains the number of semops requested by the current proc (whatever that proc is) R17 = 1 from addr 241
 PR = 0 SP = 999 PC = 172 MD = 1 qI = 0
ProgramCounter::fetch() line 172
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;172=$procsemtop: R22 contains the address of the current semaphore index R22 = 242
 PR = 0 SP = 999 PC = 173 MD = 1 qI = 0
ProgramCounter::fetch() line 173
CPU(M)::execute() pr 0 LDMEM R22 R18      ;173 R18 contains the current semaphore index R18 = 0 from addr 242
 PR = 0 SP = 999 PC = 174 MD = 1 qI = 0
ProgramCounter::fetch() line 174
CPU(M)::execute() pr 0 ADDRG R18 R18 R15  ;174 R18 now contains the address of the current semaphore R18 = 100
 PR = 0 SP = 999 PC = 175 MD = 1 qI = 0
ProgramCounter::fetch() line 175
CPU(M)::execute() pr 0 LDMEM R18 R19      ;175 R19 contains the state value of the current semaphore R19 = 0 from addr 100
 PR = 0 SP = 999 PC = 176 MD = 1 qI = 0
ProgramCounter::fetch() line 176
CPU(M)::execute() pr 0 SUBRG R19 R19 R16  ;176 prepare the test whether the current semaphore is in the P state (then R19 is going to be zero) R19 = -1
 PR = 0 SP = 999 PC = 177 MD = 1 qI = 0
ProgramCounter::fetch() line 177
CPU(M)::execute() pr 0 ADDRG R22 R22 R16  ;177 R22 now contains the address of the current semop  R22 = 243
 PR = 0 SP = 999 PC = 178 MD = 1 qI = 0
ProgramCounter::fetch() line 178
CPU(M)::execute() pr 0 LDMEM R22 R21      ;178 R21 now contains the semop code for the current semaphore R21 = 0 from addr 243
 PR = 0 SP = 999 PC = 179 MD = 1 qI = 0
ProgramCounter::fetch() line 179
CPU(M)::execute() pr 0 SUBRG R21 R21 R16  ;179 prepare the test whether the current semop code is P() (then R21 is going to be zero) R21 = -1
 PR = 0 SP = 999 PC = 180 MD = 1 qI = 0
ProgramCounter::fetch() line 180
CPU(M)::execute() pr 0 JNZRI R19 4 ;180 jump to $maybeDoPorVonSemV: if the current semaphore is in the V state non zero, PC = 185
 PR = 0 SP = 999 PC = 185 MD = 1 qI = 0
ProgramCounter::fetch() line 185
CPU(M)::execute() pr 0 JZROI R13 2 ;185=$maybeDoPorVonSemV: jump to $nextsem if we only need to examine and not also do it non zero, PC = 186
 PR = 0 SP = 999 PC = 186 MD = 1 qI = 0
ProgramCounter::fetch() line 186
CPU(M)::execute() pr 0 JNZRI R21 1 ;186 jump to $nextsem: if the current semop code is V(), because V() on a semaphore in state V is a no-op non zero, PC = 188
 PR = 0 SP = 999 PC = 188 MD = 1 qI = 0
ProgramCounter::fetch() line 188
CPU(M)::execute() pr 0 SUBRG R17 R17 R16  ;188=$nextsem: decrement semaphore loop counter R17 = 0
 PR = 0 SP = 999 PC = 189 MD = 1 qI = 0
ProgramCounter::fetch() line 189
CPU(M)::execute() pr 0 JNZRI R17 -18 ;189 jump to $procsemtop: if we have more semaphores to examine and perphaps operate upon zero, PC = 190
 PR = 0 SP = 999 PC = 190 MD = 1 qI = 0
ProgramCounter::fetch() line 190
CPU(M)::execute() pr 0 RETSB R16          ;190 we are all done, we return with 1 in R16 (and use the fact that the stack frame width is also 1) PC = 98
 PR = 0 SP = 1000 PC = 98 MD = 1 qI = 0
ProgramCounter::fetch() line 98
CPU(M)::execute() pr 0 JZROI R16 68   ;98 this should never ever happen non zero, PC = 99
 PR = 0 SP = 1000 PC = 99 MD = 1 qI = 0
ProgramCounter::fetch() line 99
CPU(M)::execute() pr 0 SETRI R6 2         ;99 the Running state, for the ready process which we just found R6 = 2
 PR = 0 SP = 1000 PC = 100 MD = 1 qI = 0
ProgramCounter::fetch() line 100
CPU(M)::execute() pr 0 STMEM R0 R6        ;100 change the process state back to running (address in R0) R6 = 2 to addr 21
 PR = 0 SP = 1000 PC = 101 MD = 1 qI = 0
ProgramCounter::fetch() line 101
CPU(M)::execute() pr 0 SETRI R6 20        ;101 offset to get the process id from the process slot address R6 = 20
 PR = 0 SP = 1000 PC = 102 MD = 1 qI = 0
ProgramCounter::fetch() line 102
CPU(M)::execute() pr 0 SUBRG R0 R0 R6     ;102 get the process id in R0 R0 = 1
 PR = 0 SP = 1000 PC = 103 MD = 1 qI = 0
ProgramCounter::fetch() line 103
CPU(M)::execute() pr 0 SETRI R1 0         ;103 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 104 MD = 1 qI = 0
ProgramCounter::fetch() line 104
CPU(M)::execute() pr 0 STMEM R1 R0        ;104 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 105 MD = 1 qI = 0
ProgramCounter::fetch() line 105
CPU(M)::execute() pr 0 LDPSW R0           ;105 go on to execute proc of id R0  , @@end of interrupt #4@@  PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1 R0 = 0 R1 = 0 R2 = 1 R3 = 220 R4 = 4 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 17 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 1 JZROI R6 -5	  ; jump back to waitLoop if the value read from shmem is zero non zero, PC = 18
 PR = 1 SP = 1000 PC = 18 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 1 SETRI R3 300	  ; some address in process memory R3 = 300
 PR = 1 SP = 1000 PC = 19 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 1 STMEM R3 R6	  ; store the value read from shared memory at that address in proc mem R6 = 65 to addr 300
 PR = 1 SP = 1000 PC = 20 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 1 SETRI R4 380	  ; some other address in process memory, for the "format"  R4 = 380
 PR = 1 SP = 1000 PC = 21 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 1 SETRI R1 1	  ; type char R1 = 1
 PR = 1 SP = 1000 PC = 22 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 1 STMEM R4 R1	  ; store the type value R1 = 1 to addr 380
 PR = 1 SP = 1000 PC = 23 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 1 SETRI R2 1	  ; how many elements -- just one R2 = 1
 PR = 1 SP = 1000 PC = 24 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 1 SETRI R0 5	  ; int number for consoleOut request R0 = 5
 PR = 1 SP = 1000 PC = 25 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 1 CLINT R0          ; call interruption int5 for kernel consoleOut PR = 0 SP = 1000 PC = 106 MD = 1 qI = 0 R0 = 5 R1 = 1 R2 = 1 R3 = 300 R4 = 380 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 106 MD = 1 qI = 0
ProgramCounter::fetch() line 106
CPU(M)::execute() pr 0 SETRI R0 0         ;106=$int5: consoleOut request for current process  , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 107 MD = 1 qI = 0
ProgramCounter::fetch() line 107
CPU(M)::execute() pr 0 LDMEM R0 R1        ;107 R1 now has the pid of the process which is requesting the consoleOut operation R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 108 MD = 1 qI = 0
ProgramCounter::fetch() line 108
CPU(M)::execute() pr 0 SETRI R6 20	   ;108 offset to get the process slot address from the process id R6 = 20
 PR = 0 SP = 1000 PC = 109 MD = 1 qI = 0
ProgramCounter::fetch() line 109
CPU(M)::execute() pr 0 ADDRG R0 R1 R6	   ;109 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 110 MD = 1 qI = 0
ProgramCounter::fetch() line 110
CPU(M)::execute() pr 0 SETRI R5 1	   ;110 the readyToRun state R5 = 1
 PR = 0 SP = 1000 PC = 111 MD = 1 qI = 0
ProgramCounter::fetch() line 111
CPU(M)::execute() pr 0 STMEM R0 R5	   ;111 store the readyToRun state for the current process R5 = 1 to addr 21
 PR = 0 SP = 1000 PC = 112 MD = 1 qI = 0
ProgramCounter::fetch() line 112
CPU(M)::execute() pr 0 SETRI R7 301	   ;112 The address in kernel memory where we need to write the # of items for the consoleOut R7 = 301
 PR = 0 SP = 1000 PC = 113 MD = 1 qI = 0
ProgramCounter::fetch() line 113
CPU(M)::execute() pr 0 STMEM R7 R5        ;113 just one item for now R5 = 1 to addr 301
 PR = 0 SP = 1000 PC = 114 MD = 1 qI = 0
ProgramCounter::fetch() line 114
CPU(M)::execute() pr 0 LDPRM R1 R3 R6     ;114 R6 now contains the first item to be obtained (read) and thus sent to consoleOut (recall R3 is given to us by the proc) CPU(M)::execute() pr 0 LDPRM R1 R3 R6     ;114 R6 now contains the first item to be obtained (read) and thus sent to consoleOut (recall R3 is given to us by the proc) R6 = 65 from addr 300 of proc 1
 PR = 0 SP = 1000 PC = 115 MD = 1 qI = 0
ProgramCounter::fetch() line 115
CPU(M)::execute() pr 0 SETRI R8 304	   ;115 The address in kernel memory where we decided to write the item (copying it from the process memory) R8 = 304
 PR = 0 SP = 1000 PC = 116 MD = 1 qI = 0
ProgramCounter::fetch() line 116
CPU(M)::execute() pr 0 STMEM R8 R6 	   ;116 now writing the item (from R6) which we just read from the process memory a few lines above, at address 304 in kernel mem R6 = 65 to addr 304
 PR = 0 SP = 1000 PC = 117 MD = 1 qI = 0
ProgramCounter::fetch() line 117
CPU(M)::execute() pr 0 SETRI R7 302	   ;117 The address in kernel memory where we need to write the start address (param) where to read the items for the consoleOut R7 = 302
 PR = 0 SP = 1000 PC = 118 MD = 1 qI = 0
ProgramCounter::fetch() line 118
CPU(M)::execute() pr 0 STMEM R7 R8	   ;118 now effectively preparing the start address "parameter" for consoleOut (i.e. write the number '304' at address 302) R8 = 304 to addr 302
 PR = 0 SP = 1000 PC = 119 MD = 1 qI = 0
ProgramCounter::fetch() line 119
CPU(M)::execute() pr 0 LDPRM R1 R4 R7     ;119 R7 now contains the type of first item to be obtained (read) and thus sent to consoleOut CPU(M)::execute() pr 0 LDPRM R1 R4 R7     ;119 R7 now contains the type of first item to be obtained (read) and thus sent to consoleOut R7 = 1 from addr 380 of proc 1
 PR = 0 SP = 1000 PC = 120 MD = 1 qI = 0
ProgramCounter::fetch() line 120
CPU(M)::execute() pr 0 SETRI R8 404	   ;120 The address in kernel memory where we decided to write the item (copying it from the process memory) R8 = 404
 PR = 0 SP = 1000 PC = 121 MD = 1 qI = 0
ProgramCounter::fetch() line 121
CPU(M)::execute() pr 0 STMEM R8 R7 	   ;121 now writing the item type (from R7) which we just read from the process memory a few lines above, at address 404 in kernel mem R7 = 1 to addr 404
 PR = 0 SP = 1000 PC = 122 MD = 1 qI = 0
ProgramCounter::fetch() line 122
CPU(M)::execute() pr 0 SETRI R7 303	   ;122 The address in kernel memory where we need to write the start address (param) where to read the item types for the consoleOut R7 = 303
 PR = 0 SP = 1000 PC = 123 MD = 1 qI = 0
ProgramCounter::fetch() line 123
CPU(M)::execute() pr 0 STMEM R7 R8	   ;123 now effectively preparing the type vect start address "parameter" for consoleOut (i.e. write the number '404' at address 303) R8 = 404 to addr 303
 PR = 0 SP = 1000 PC = 124 MD = 1 qI = 0
ProgramCounter::fetch() line 124
CPU(M)::execute() pr 0 SETRI R7 300	   ;124 The address in kernel memory where, by writing a value of 1, we trigger the consoleOut R7 = 300
 PR = 0 SP = 1000 PC = 125 MD = 1 qI = 0
ProgramCounter::fetch() line 125
ConsoleOutput for 1 items:
A
ConsoleOutput end
 PR = 0 SP = 1000 PC = 126 MD = 1 qI = 0
ProgramCounter::fetch() line 126
CPU(M)::execute() pr 0 JMBSI 1        ;126 we are done, so we make an absolute jump to $int1: to keep going , @@end of interrupt #5@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 1 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 2
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 2
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -2
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 22
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 202
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 0 from addr 22
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: zero, PC = 40
 PR = 0 SP = 1000 PC = 40 MD = 1 qI = 0
ProgramCounter::fetch() line 40
CPU(M)::execute() pr 0 ADDRG R0 R0 R2     ;40=$nextproc: increment the pid for the next process to study  R0 = 3
 PR = 0 SP = 1000 PC = 41 MD = 1 qI = 0
ProgramCounter::fetch() line 41
CPU(M)::execute() pr 0 SUBRG R1 R1 R2     ;41 decrement loop counter R1 = 2
 PR = 0 SP = 1000 PC = 42 MD = 1 qI = 0
ProgramCounter::fetch() line 42
CPU(M)::execute() pr 0 JNZRI R1  -30     ;42 jump to $top: loop for max number processes non zero, PC = 13
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 3
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -1
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 23
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 203
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 0 from addr 23
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: zero, PC = 40
 PR = 0 SP = 1000 PC = 40 MD = 1 qI = 0
ProgramCounter::fetch() line 40
CPU(M)::execute() pr 0 ADDRG R0 R0 R2     ;40=$nextproc: increment the pid for the next process to study  R0 = 4
 PR = 0 SP = 1000 PC = 41 MD = 1 qI = 0
ProgramCounter::fetch() line 41
CPU(M)::execute() pr 0 SUBRG R1 R1 R2     ;41 decrement loop counter R1 = 1
 PR = 0 SP = 1000 PC = 42 MD = 1 qI = 0
ProgramCounter::fetch() line 42
CPU(M)::execute() pr 0 JNZRI R1  -30     ;42 jump to $top: loop for max number processes non zero, PC = 13
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 4
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = 0
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue zero, PC = 16
 PR = 0 SP = 1000 PC = 16 MD = 1 qI = 0
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 0 SETRI R0 1	   ;16 otherwise, we need to set R0 to 1 to wrap around (pid zero is for the kernel) R0 = 1
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 21
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 201
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 1 from addr 21
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: non zero, PC = 23
 PR = 0 SP = 1000 PC = 23 MD = 1 qI = 0
ProgramCounter::fetch() line 23
CPU(M)::execute() pr 0 SETRI R6 1         ;23 yes, we found at least one non-exited process R6 = 1
 PR = 0 SP = 1000 PC = 24 MD = 1 qI = 0
ProgramCounter::fetch() line 24
CPU(M)::execute() pr 0 SETRG R12 R8	   ;24 save R8 into R12, we need the state once again R12 = 1
 PR = 0 SP = 1000 PC = 25 MD = 1 qI = 0
ProgramCounter::fetch() line 25
CPU(M)::execute() pr 0 SUBRG R8 R8 R3     ;25 prepare the test whether this process is in the ready state R8 = 0
 PR = 0 SP = 1000 PC = 26 MD = 1 qI = 0
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 0 JZROI R8 21 ;26 jump to $startproc: for id R0 and process table address R10, since it is indeed ready zero, PC = 48
 PR = 0 SP = 1000 PC = 48 MD = 1 qI = 0
ProgramCounter::fetch() line 48
CPU(M)::execute() pr 0 SETRI R3 2         ;48=$startproc: the Running state, for the ready process which we just found R3 = 2
 PR = 0 SP = 1000 PC = 49 MD = 1 qI = 0
ProgramCounter::fetch() line 49
CPU(M)::execute() pr 0 STMEM R10 R3       ;49 change the process state to running (address in R0) R3 = 2 to addr 21
 PR = 0 SP = 1000 PC = 50 MD = 1 qI = 0
ProgramCounter::fetch() line 50
CPU(M)::execute() pr 0 SETRI R1 0         ;50 address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 51 MD = 1 qI = 0
ProgramCounter::fetch() line 51
CPU(M)::execute() pr 0 STMEM R1 R0        ;51 store the (newly become) current proc id R0 = 1 to addr 0
 PR = 0 SP = 1000 PC = 52 MD = 1 qI = 0
ProgramCounter::fetch() line 52
CPU(M)::execute() pr 0 LDPSW R0           ;52 go on to execute proc of id R0    , @@end of interrupt #1@@  PR = 1 SP = 1000 PC = 26 MD = 0 qI = 1 R0 = 5 R1 = 1 R2 = 1 R3 = 300 R4 = 380 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 0 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 1 SP = 1000 PC = 26 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 26
CPU(M)::execute() pr 1 SETRI R9 2        ; int number for exit() R9 = 2
 PR = 1 SP = 1000 PC = 27 MD = 0 qI = 1
Not interrupted this time.
ProgramCounter::fetch() line 27
CPU(M)::execute() pr 1 CLINT R9          ; kernel int2 exits the process PR = 0 SP = 1000 PC = 53 MD = 1 qI = 0 R0 = 5 R1 = 1 R2 = 1 R3 = 300 R4 = 380 R5 = 10 R6 = 65 R7 = 0 R8 = 0 R9 = 2 R10 = 0 R11 = 0 R12 = 0 R13 = 0 R14 = 0 R15 = 0 R16 = 0 R17 = 0 R18 = 0 R19 = 0 R20 = 0 R21 = 0 R22 = 0 R23 = 0 R24 = 0 R25 = 0 R26 = 0 R27 = 0 R28 = 0 R29 = 0 R30 = 0 R31 = 0
 PR = 0 SP = 1000 PC = 53 MD = 1 qI = 0
ProgramCounter::fetch() line 53
CPU(M)::execute() pr 0 SETRI R0 0         ;53=$int2: exit current process    , the address where its pid is stored R0 = 0
 PR = 0 SP = 1000 PC = 54 MD = 1 qI = 0
ProgramCounter::fetch() line 54
CPU(M)::execute() pr 0 LDMEM R0 R1        ;54 R1 now has the pid of the process which is now exiting R1 = 1 from addr 0
 PR = 0 SP = 1000 PC = 55 MD = 1 qI = 0
ProgramCounter::fetch() line 55
CPU(M)::execute() pr 0 SETRI R2 20        ;55 offset to get the process slot address from the process id R2 = 20
 PR = 0 SP = 1000 PC = 56 MD = 1 qI = 0
ProgramCounter::fetch() line 56
CPU(M)::execute() pr 0 ADDRG R0 R1 R2     ;56 R0 now contains the process slot address R0 = 21
 PR = 0 SP = 1000 PC = 57 MD = 1 qI = 0
ProgramCounter::fetch() line 57
CPU(M)::execute() pr 0 SETRI R3 0         ;57 the exited process state value R3 = 0
 PR = 0 SP = 1000 PC = 58 MD = 1 qI = 0
ProgramCounter::fetch() line 58
CPU(M)::execute() pr 0 STMEM R0 R3        ;58 set the state of the process to exit R3 = 0 to addr 21
 PR = 0 SP = 1000 PC = 59 MD = 1 qI = 0
ProgramCounter::fetch() line 59
CPU(M)::execute() pr 0 JMBSI 1        ;59 absolute jump to $int1: to keep going    , @@end of interrupt #2@@ zero, PC = 1
 PR = 0 SP = 1000 PC = 1 MD = 1 qI = 0
ProgramCounter::fetch() line 1
CPU(M)::execute() pr 0 SETRI R1 0         ;1=$int1: address where the current proc id is stored R1 = 0
 PR = 0 SP = 1000 PC = 2 MD = 1 qI = 0
ProgramCounter::fetch() line 2
CPU(M)::execute() pr 0 LDMEM R1 R0	   ;2 get the last scheduled process id, to start from right after it (round robin) R0 = 1 from addr 0
 PR = 0 SP = 1000 PC = 3 MD = 1 qI = 0
ProgramCounter::fetch() line 3
CPU(M)::execute() pr 0 SETRI R2 1         ;3 the increment for process table slots R2 = 1
 PR = 0 SP = 1000 PC = 4 MD = 1 qI = 0
ProgramCounter::fetch() line 4
CPU(M)::execute() pr 0 ADDRG R0 R0 R2	   ;4 the next process id to study, or one past the last (then we are going to wrap around) R0 = 2
 PR = 0 SP = 1000 PC = 5 MD = 1 qI = 0
ProgramCounter::fetch() line 5
CPU(M)::execute() pr 0 SETRI R11 20       ;5 the address where the number of processes is stored R11 = 20
 PR = 0 SP = 1000 PC = 6 MD = 1 qI = 0
ProgramCounter::fetch() line 6
CPU(M)::execute() pr 0 LDMEM R11 R1       ;6 R1 now contains the number of processes R1 = 3 from addr 20
 PR = 0 SP = 1000 PC = 7 MD = 1 qI = 0
ProgramCounter::fetch() line 7
CPU(M)::execute() pr 0 SETRG R9 R1        ;7 save R1 into R9, so R9 now also contains the number of processes -- constant R9 = 3
 PR = 0 SP = 1000 PC = 8 MD = 1 qI = 0
ProgramCounter::fetch() line 8
CPU(M)::execute() pr 0 ADDRG R9 R9 R2     ;8 actually make R9 one larger because proc id are from 1 to R1 , R9 is constant, needed for the wrap around test R9 = 4
 PR = 0 SP = 1000 PC = 9 MD = 1 qI = 0
ProgramCounter::fetch() line 9
CPU(M)::execute() pr 0 SETRI R3 1         ;9 the ReadyToRun process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R3 = 1
 PR = 0 SP = 1000 PC = 10 MD = 1 qI = 0
ProgramCounter::fetch() line 10
CPU(M)::execute() pr 0 SETRI R4 3         ;10 the SemWait process state value (proc states: 0(exit), 1(ready), 2(running), 3(semwait), 4(netwait)...) R4 = 3
 PR = 0 SP = 1000 PC = 11 MD = 1 qI = 0
ProgramCounter::fetch() line 11
CPU(M)::execute() pr 0 SETRI R15 100      ;11 the start address of the semaphore vector (where we keep the semaphore state values) R15 = 100
 PR = 0 SP = 1000 PC = 12 MD = 1 qI = 0
ProgramCounter::fetch() line 12
CPU(M)::execute() pr 0 SETRI R6 0         ;12 for now 'no', we did not find any non-exited process yet     R6 = 0
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 2
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -2
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 22
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 202
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 0 from addr 22
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: zero, PC = 40
 PR = 0 SP = 1000 PC = 40 MD = 1 qI = 0
ProgramCounter::fetch() line 40
CPU(M)::execute() pr 0 ADDRG R0 R0 R2     ;40=$nextproc: increment the pid for the next process to study  R0 = 3
 PR = 0 SP = 1000 PC = 41 MD = 1 qI = 0
ProgramCounter::fetch() line 41
CPU(M)::execute() pr 0 SUBRG R1 R1 R2     ;41 decrement loop counter R1 = 2
 PR = 0 SP = 1000 PC = 42 MD = 1 qI = 0
ProgramCounter::fetch() line 42
CPU(M)::execute() pr 0 JNZRI R1  -30     ;42 jump to $top: loop for max number processes non zero, PC = 13
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 3
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = -1
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue non zero, PC = 17
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 23
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 203
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 0 from addr 23
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: zero, PC = 40
 PR = 0 SP = 1000 PC = 40 MD = 1 qI = 0
ProgramCounter::fetch() line 40
CPU(M)::execute() pr 0 ADDRG R0 R0 R2     ;40=$nextproc: increment the pid for the next process to study  R0 = 4
 PR = 0 SP = 1000 PC = 41 MD = 1 qI = 0
ProgramCounter::fetch() line 41
CPU(M)::execute() pr 0 SUBRG R1 R1 R2     ;41 decrement loop counter R1 = 1
 PR = 0 SP = 1000 PC = 42 MD = 1 qI = 0
ProgramCounter::fetch() line 42
CPU(M)::execute() pr 0 JNZRI R1  -30     ;42 jump to $top: loop for max number processes non zero, PC = 13
 PR = 0 SP = 1000 PC = 13 MD = 1 qI = 0
ProgramCounter::fetch() line 13
CPU(M)::execute() pr 0 SETRG R7 R0        ;13=$top: copy R0 for the test for the wrap around R7 = 4
 PR = 0 SP = 1000 PC = 14 MD = 1 qI = 0
ProgramCounter::fetch() line 14
CPU(M)::execute() pr 0 SUBRG R7 R7 R9	   ;14 prepare the test for R0 wrap around R7 = 0
 PR = 0 SP = 1000 PC = 15 MD = 1 qI = 0
ProgramCounter::fetch() line 15
CPU(M)::execute() pr 0 JNZRI R7 1  ;15 if R7 (that is R0) is not equal to R9 (the number of processes) we can continue zero, PC = 16
 PR = 0 SP = 1000 PC = 16 MD = 1 qI = 0
ProgramCounter::fetch() line 16
CPU(M)::execute() pr 0 SETRI R0 1	   ;16 otherwise, we need to set R0 to 1 to wrap around (pid zero is for the kernel) R0 = 1
 PR = 0 SP = 1000 PC = 17 MD = 1 qI = 0
ProgramCounter::fetch() line 17
CPU(M)::execute() pr 0 SETRG R10 R11	   ;17=$nextPid: prepare the offset for the process table start address R10 = 20
 PR = 0 SP = 1000 PC = 18 MD = 1 qI = 0
ProgramCounter::fetch() line 18
CPU(M)::execute() pr 0 ADDRG R10 R10 R0   ;18 now R10 contains the address of the current process slot in the process table R10 = 21
 PR = 0 SP = 1000 PC = 19 MD = 1 qI = 0
ProgramCounter::fetch() line 19
CPU(M)::execute() pr 0 SETRI R14 200      ;19 the start of the proc sem waitlists address vect, one list for each proc, (count,(semId,semOp),(semId,semOp),...) R14 = 200
 PR = 0 SP = 1000 PC = 20 MD = 1 qI = 0
ProgramCounter::fetch() line 20
CPU(M)::execute() pr 0 ADDRG R14 R14 R0   ;20 the address of the start of the proc sem waitlists address vect for the current process R14 = 201
 PR = 0 SP = 1000 PC = 21 MD = 1 qI = 0
ProgramCounter::fetch() line 21
CPU(M)::execute() pr 0 LDMEM R10 R8       ;21 get the state of the current process (address in R10) into R8 R8 = 0 from addr 21
 PR = 0 SP = 1000 PC = 22 MD = 1 qI = 0
ProgramCounter::fetch() line 22
CPU(M)::execute() pr 0 JZROI R8 17 ;22 this process is exited, we jump to $nextproc: zero, PC = 40
 PR = 0 SP = 1000 PC = 40 MD = 1 qI = 0
ProgramCounter::fetch() line 40
CPU(M)::execute() pr 0 ADDRG R0 R0 R2     ;40=$nextproc: increment the pid for the next process to study  R0 = 2
 PR = 0 SP = 1000 PC = 41 MD = 1 qI = 0
ProgramCounter::fetch() line 41
CPU(M)::execute() pr 0 SUBRG R1 R1 R2     ;41 decrement loop counter R1 = 0
 PR = 0 SP = 1000 PC = 42 MD = 1 qI = 0
ProgramCounter::fetch() line 42
CPU(M)::execute() pr 0 JNZRI R1  -30     ;42 jump to $top: loop for max number processes zero, PC = 43
 PR = 0 SP = 1000 PC = 43 MD = 1 qI = 0
ProgramCounter::fetch() line 43
CPU(M)::execute() pr 0 JNZRI R6 2     ;43 no ready proc but at least one not exited, so we go to $wait:  zero, PC = 44
 PR = 0 SP = 1000 PC = 44 MD = 1 qI = 0
ProgramCounter::fetch() line 44
CPU(M)::execute() pr 0 SDOWN              ;44 all processes have exited, we're done, system going down
 PR = 0 SP = 1000 PC = 45 MD = 1 qI = 0
CPU M is now fully stopped, total 1503 instructions overall.

Memory dump at end time
Shared memory
0	1000 0 0 0 0 0 0 0 0 0 
10	65 0 0 0 0 0 0 0 0 0 
20	0 0 0 0 0 0 0 0 0 0 
30	0 0 0 0 0 0 0 0 0 0 
40	0 0 0 0 0 0 0 0 0 0 
50	0 0 0 0 0 0 0 0 0 0 
60	0 0 0 0 0 0 0 0 0 0 
70	0 0 0 0 0 0 0 0 0 0 
80	0 0 0 0 0 0 0 0 0 0 
90	0 0 0 0 0 0 0 0 0 0 
100	0 0 0 0 0 0 0 0 0 0 
110	0 0 0 0 0 0 0 0 0 0 
120	0 0 0 0 0 0 0 0 0 0 
130	0 0 0 0 0 0 0 0 0 0 
140	0 0 0 0 0 0 0 0 0 0 
150	0 0 0 0 0 0 0 0 0 0 
160	0 0 0 0 0 0 0 0 0 0 
170	0 0 0 0 0 0 0 0 0 0 
180	0 0 0 0 0 0 0 0 0 0 
190	0 0 0 0 0 0 0 0 0 0 
200	0 0 0 0 0 0 0 0 0 0 
210	0 0 0 0 0 0 0 0 0 0 
220	0 0 0 0 0 0 0 0 0 0 
230	0 0 0 0 0 0 0 0 0 0 
240	0 0 0 0 0 0 0 0 0 0 
250	0 0 0 0 0 0 0 0 0 0 
260	0 0 0 0 0 0 0 0 0 0 
270	0 0 0 0 0 0 0 0 0 0 
280	0 0 0 0 0 0 0 0 0 0 
290	0 0 0 0 0 0 0 0 0 0 
300	0 0 0 0 0 0 0 0 0 0 
310	0 0 0 0 0 0 0 0 0 0 
320	0 0 0 0 0 0 0 0 0 0 
330	0 0 0 0 0 0 0 0 0 0 
340	0 0 0 0 0 0 0 0 0 0 
350	0 0 0 0 0 0 0 0 0 0 
360	0 0 0 0 0 0 0 0 0 0 
370	0 0 0 0 0 0 0 0 0 0 
380	0 0 0 0 0 0 0 0 0 0 
390	0 0 0 0 0 0 0 0 0 0 
400	0 0 0 0 0 0 0 0 0 0 
410	0 0 0 0 0 0 0 0 0 0 
420	0 0 0 0 0 0 0 0 0 0 
430	0 0 0 0 0 0 0 0 0 0 
440	0 0 0 0 0 0 0 0 0 0 
450	0 0 0 0 0 0 0 0 0 0 
460	0 0 0 0 0 0 0 0 0 0 
470	0 0 0 0 0 0 0 0 0 0 
480	0 0 0 0 0 0 0 0 0 0 
490	0 0 0 0 0 0 0 0 0 0 
500	0 0 0 0 0 0 0 0 0 0 
510	0 0 0 0 0 0 0 0 0 0 
520	0 0 0 0 0 0 0 0 0 0 
530	0 0 0 0 0 0 0 0 0 0 
540	0 0 0 0 0 0 0 0 0 0 
550	0 0 0 0 0 0 0 0 0 0 
560	0 0 0 0 0 0 0 0 0 0 
570	0 0 0 0 0 0 0 0 0 0 
580	0 0 0 0 0 0 0 0 0 0 
590	0 0 0 0 0 0 0 0 0 0 
600	0 0 0 0 0 0 0 0 0 0 
610	0 0 0 0 0 0 0 0 0 0 
620	0 0 0 0 0 0 0 0 0 0 
630	0 0 0 0 0 0 0 0 0 0 
640	0 0 0 0 0 0 0 0 0 0 
650	0 0 0 0 0 0 0 0 0 0 
660	0 0 0 0 0 0 0 0 0 0 
670	0 0 0 0 0 0 0 0 0 0 
680	0 0 0 0 0 0 0 0 0 0 
690	0 0 0 0 0 0 0 0 0 0 
700	0 0 0 0 0 0 0 0 0 0 
710	0 0 0 0 0 0 0 0 0 0 
720	0 0 0 0 0 0 0 0 0 0 
730	0 0 0 0 0 0 0 0 0 0 
740	0 0 0 0 0 0 0 0 0 0 
750	0 0 0 0 0 0 0 0 0 0 
760	0 0 0 0 0 0 0 0 0 0 
770	0 0 0 0 0 0 0 0 0 0 
780	0 0 0 0 0 0 0 0 0 0 
790	0 0 0 0 0 0 0 0 0 0 
800	0 0 0 0 0 0 0 0 0 0 
810	0 0 0 0 0 0 0 0 0 0 
820	0 0 0 0 0 0 0 0 0 0 
830	0 0 0 0 0 0 0 0 0 0 
840	0 0 0 0 0 0 0 0 0 0 
850	0 0 0 0 0 0 0 0 0 0 
860	0 0 0 0 0 0 0 0 0 0 
870	0 0 0 0 0 0 0 0 0 0 
880	0 0 0 0 0 0 0 0 0 0 
890	0 0 0 0 0 0 0 0 0 0 
900	0 0 0 0 0 0 0 0 0 0 
910	0 0 0 0 0 0 0 0 0 0 
920	0 0 0 0 0 0 0 0 0 0 
930	0 0 0 0 0 0 0 0 0 0 
940	0 0 0 0 0 0 0 0 0 0 
950	0 0 0 0 0 0 0 0 0 0 
960	0 0 0 0 0 0 0 0 0 0 
970	0 0 0 0 0 0 0 0 0 0 
980	0 0 0 0 0 0 0 0 0 0 
990	0 0 0 0 0 0 0 0 0 0 
-----------------------------------
Proc 0
0	1 1 53 60 67 106 127 0 0 0 
10	0 0 0 0 0 0 0 0 0 0 
20	3 0 0 0 0 0 0 0 0 0 
30	0 0 0 0 0 0 0 0 0 0 
40	0 0 0 0 0 0 0 0 0 0 
50	0 0 0 0 0 0 0 0 0 0 
60	0 0 0 0 0 0 0 0 0 0 
70	0 0 0 0 0 0 0 0 0 0 
80	0 0 0 0 0 0 0 0 0 0 
90	0 0 0 0 0 0 0 0 0 0 
100	0 0 0 0 0 0 0 0 0 0 
110	0 0 0 0 0 0 0 0 0 0 
120	0 0 0 0 0 0 0 0 0 0 
130	0 0 0 0 0 0 0 0 0 0 
140	0 0 0 0 0 0 0 0 0 0 
150	0 0 0 0 0 0 0 0 0 0 
160	0 0 0 0 0 0 0 0 0 0 
170	0 0 0 0 0 0 0 0 0 0 
180	0 0 0 0 0 0 0 0 0 0 
190	0 0 0 0 0 0 0 0 0 0 
200	220 241 262 0 0 0 0 0 0 0 
210	0 0 0 0 0 0 0 0 0 0 
220	0 0 0 0 0 0 0 0 0 0 
230	0 0 0 0 0 0 0 0 0 0 
240	0 1 0 0 0 0 0 0 0 0 
250	0 0 0 0 0 0 0 0 0 0 
260	0 0 1 0 0 0 0 0 0 0 
270	0 0 0 0 0 0 0 0 0 0 
280	0 0 0 0 0 0 0 0 0 0 
290	0 0 0 0 0 0 0 0 0 0 
300	0 1 304 404 65 0 0 0 0 0 
310	0 0 0 0 0 0 0 0 0 0 
320	0 0 0 0 0 0 0 0 0 0 
330	0 0 0 0 0 0 0 0 0 0 
340	0 0 0 0 0 0 0 0 0 0 
350	0 0 0 0 0 0 0 0 0 0 
360	0 0 0 0 0 0 0 0 0 0 
370	0 0 0 0 0 0 0 0 0 0 
380	0 0 0 0 0 0 0 0 0 0 
390	0 0 0 0 0 0 0 0 0 0 
400	0 0 0 0 1 0 0 0 0 0 
410	0 0 0 0 0 0 0 0 0 0 
420	0 0 0 0 0 0 0 0 0 0 
430	0 0 0 0 0 0 0 0 0 0 
440	0 0 0 0 0 0 0 0 0 0 
450	0 0 0 0 0 0 0 0 0 0 
460	0 0 0 0 0 0 0 0 0 0 
470	0 0 0 0 0 0 0 0 0 0 
480	0 0 0 0 0 0 0 0 0 0 
490	0 0 0 0 0 0 0 0 0 0 
500	0 0 0 0 0 0 0 0 0 0 
510	0 0 0 0 0 0 0 0 0 0 
520	0 0 0 0 0 0 0 0 0 0 
530	0 0 0 0 0 0 0 0 0 0 
540	0 0 0 0 0 0 0 0 0 0 
550	0 0 0 0 0 0 0 0 0 0 
560	0 0 0 0 0 0 0 0 0 0 
570	0 0 0 0 0 0 0 0 0 0 
580	0 0 0 0 0 0 0 0 0 0 
590	0 0 0 0 0 0 0 0 0 0 
600	0 0 0 0 0 0 0 0 0 0 
610	0 0 0 0 0 0 0 0 0 0 
620	0 0 0 0 0 0 0 0 0 0 
630	0 0 0 0 0 0 0 0 0 0 
640	0 0 0 0 0 0 0 0 0 0 
650	0 0 0 0 0 0 0 0 0 0 
660	0 0 0 0 0 0 0 0 0 0 
670	0 0 0 0 0 0 0 0 0 0 
680	0 0 0 0 0 0 0 0 0 0 
690	0 0 0 0 0 0 0 0 0 0 
700	0 0 0 0 0 0 0 0 0 0 
710	0 0 0 0 0 0 0 0 0 0 
720	0 0 0 0 0 0 0 0 0 0 
730	0 0 0 0 0 0 0 0 0 0 
740	0 0 0 0 0 0 0 0 0 0 
750	0 0 0 0 0 0 0 0 0 0 
760	0 0 0 0 0 0 0 0 0 0 
770	0 0 0 0 0 0 0 0 0 0 
780	0 0 0 0 0 0 0 0 0 0 
790	0 0 0 0 0 0 0 0 0 0 
800	0 0 0 0 0 0 0 0 0 0 
810	0 0 0 0 0 0 0 0 0 0 
820	0 0 0 0 0 0 0 0 0 0 
830	0 0 0 0 0 0 0 0 0 0 
840	0 0 0 0 0 0 0 0 0 0 
850	0 0 0 0 0 0 0 0 0 0 
860	0 0 0 0 0 0 0 0 0 0 
870	0 0 0 0 0 0 0 0 0 0 
880	0 0 0 0 0 0 0 0 0 0 
890	0 0 0 0 0 0 0 0 0 0 
900	0 0 0 0 0 0 0 0 0 0 
910	0 0 0 0 0 0 0 0 0 0 
920	0 0 0 0 0 0 0 0 0 0 
930	0 0 0 0 0 0 0 0 0 0 
940	0 0 0 0 0 0 0 0 0 0 
950	0 0 0 0 0 0 0 0 0 0 
960	0 0 0 0 0 0 0 0 0 0 
970	0 0 0 0 0 0 0 0 0 0 
980	0 0 0 0 0 0 0 0 0 0 
990	0 0 0 0 0 0 0 0 0 98 
-----------------------------------
Proc 1
0	1000 28 0 5 1 1 300 380 10 65 
10	0 0 2 0 0 0 0 0 0 0 
20	0 0 0 0 0 0 0 0 0 0 
30	0 0 0 0 0 0 0 0 0 0 
40	0 0 0 0 0 0 0 0 0 0 
50	0 0 0 0 0 0 0 0 0 0 
60	0 0 0 0 0 0 0 0 0 0 
70	0 0 0 0 0 0 0 0 0 0 
80	0 0 0 0 0 0 0 0 0 0 
90	0 0 0 0 0 0 0 0 0 0 
100	0 0 0 0 0 0 0 0 0 0 
110	0 0 0 0 0 0 0 0 0 0 
120	0 0 0 0 0 0 0 0 0 0 
130	0 0 0 0 0 0 0 0 0 0 
140	0 0 0 0 0 0 0 0 0 0 
150	0 0 0 0 0 0 0 0 0 0 
160	0 0 0 0 0 0 0 0 0 0 
170	0 0 0 0 0 0 0 0 0 0 
180	0 0 0 0 0 0 0 0 0 0 
190	0 0 0 0 0 0 0 0 0 0 
200	0 0 0 0 0 0 0 0 0 0 
210	0 1 0 0 0 0 0 0 0 0 
220	0 0 0 0 0 0 0 0 0 0 
230	0 0 0 0 0 0 0 0 0 0 
240	0 0 0 0 0 0 0 0 0 0 
250	0 0 0 0 0 0 0 0 0 0 
260	0 0 0 0 0 0 0 0 0 0 
270	0 0 0 0 0 0 0 0 0 0 
280	0 0 0 0 0 0 0 0 0 0 
290	0 0 0 0 0 0 0 0 0 0 
300	65 0 0 0 0 0 0 0 0 0 
310	0 0 0 0 0 0 0 0 0 0 
320	0 0 0 0 0 0 0 0 0 0 
330	0 0 0 0 0 0 0 0 0 0 
340	0 0 0 0 0 0 0 0 0 0 
350	0 0 0 0 0 0 0 0 0 0 
360	0 0 0 0 0 0 0 0 0 0 
370	0 0 0 0 0 0 0 0 0 0 
380	1 0 0 0 0 0 0 0 0 0 
390	0 0 0 0 0 0 0 0 0 0 
400	0 0 0 0 0 0 0 0 0 0 
410	0 0 0 0 0 0 0 0 0 0 
420	0 0 0 0 0 0 0 0 0 0 
430	0 0 0 0 0 0 0 0 0 0 
440	0 0 0 0 0 0 0 0 0 0 
450	0 0 0 0 0 0 0 0 0 0 
460	0 0 0 0 0 0 0 0 0 0 
470	0 0 0 0 0 0 0 0 0 0 
480	0 0 0 0 0 0 0 0 0 0 
490	0 0 0 0 0 0 0 0 0 0 
500	0 0 0 0 0 0 0 0 0 0 
510	0 0 0 0 0 0 0 0 0 0 
520	0 0 0 0 0 0 0 0 0 0 
530	0 0 0 0 0 0 0 0 0 0 
540	0 0 0 0 0 0 0 0 0 0 
550	0 0 0 0 0 0 0 0 0 0 
560	0 0 0 0 0 0 0 0 0 0 
570	0 0 0 0 0 0 0 0 0 0 
580	0 0 0 0 0 0 0 0 0 0 
590	0 0 0 0 0 0 0 0 0 0 
600	0 0 0 0 0 0 0 0 0 0 
610	0 0 0 0 0 0 0 0 0 0 
620	0 0 0 0 0 0 0 0 0 0 
630	0 0 0 0 0 0 0 0 0 0 
640	0 0 0 0 0 0 0 0 0 0 
650	0 0 0 0 0 0 0 0 0 0 
660	0 0 0 0 0 0 0 0 0 0 
670	0 0 0 0 0 0 0 0 0 0 
680	0 0 0 0 0 0 0 0 0 0 
690	0 0 0 0 0 0 0 0 0 0 
700	0 0 0 0 0 0 0 0 0 0 
710	0 0 0 0 0 0 0 0 0 0 
720	0 0 0 0 0 0 0 0 0 0 
730	0 0 0 0 0 0 0 0 0 0 
740	0 0 0 0 0 0 0 0 0 0 
750	0 0 0 0 0 0 0 0 0 0 
760	0 0 0 0 0 0 0 0 0 0 
770	0 0 0 0 0 0 0 0 0 0 
780	0 0 0 0 0 0 0 0 0 0 
790	0 0 0 0 0 0 0 0 0 0 
800	0 0 0 0 0 0 0 0 0 0 
810	0 0 0 0 0 0 0 0 0 0 
820	0 0 0 0 0 0 0 0 0 0 
830	0 0 0 0 0 0 0 0 0 0 
840	0 0 0 0 0 0 0 0 0 0 
850	0 0 0 0 0 0 0 0 0 0 
860	0 0 0 0 0 0 0 0 0 0 
870	0 0 0 0 0 0 0 0 0 0 
880	0 0 0 0 0 0 0 0 0 0 
890	0 0 0 0 0 0 0 0 0 0 
900	0 0 0 0 0 0 0 0 0 0 
910	0 0 0 0 0 0 0 0 0 0 
920	0 0 0 0 0 0 0 0 0 0 
930	0 0 0 0 0 0 0 0 0 0 
940	0 0 0 0 0 0 0 0 0 0 
950	0 0 0 0 0 0 0 0 0 0 
960	0 0 0 0 0 0 0 0 0 0 
970	0 0 0 0 0 0 0 0 0 0 
980	0 0 0 0 0 0 0 0 0 0 
990	0 0 0 0 0 0 0 0 0 0 
-----------------------------------
Proc 2
0	1000 20 0 0 0 1 225 4 10 65 
10	0 0 2 0 0 0 0 0 0 0 
20	0 0 0 0 0 0 0 0 0 0 
30	0 0 0 0 0 0 0 0 0 0 
40	0 0 0 0 0 0 0 0 0 0 
50	0 0 0 0 0 0 0 0 0 0 
60	0 0 0 0 0 0 0 0 0 0 
70	0 0 0 0 0 0 0 0 0 0 
80	0 0 0 0 0 0 0 0 0 0 
90	0 0 0 0 0 0 0 0 0 0 
100	0 0 0 0 0 0 0 0 0 0 
110	0 0 0 0 0 0 0 0 0 0 
120	0 0 0 0 0 0 0 0 0 0 
130	0 0 0 0 0 0 0 0 0 0 
140	0 0 0 0 0 0 0 0 0 0 
150	0 0 0 0 0 0 0 0 0 0 
160	0 0 0 0 0 0 0 0 0 0 
170	0 0 0 0 0 0 0 0 0 0 
180	0 0 0 0 0 0 0 0 0 0 
190	0 0 0 0 0 0 0 0 0 0 
200	0 0 0 0 0 0 0 0 0 0 
210	0 0 0 0 0 0 1 0 0 0 
220	0 0 0 0 0 0 0 0 0 0 
230	0 0 0 0 0 0 0 0 0 0 
240	0 0 0 0 0 0 0 0 0 0 
250	0 0 0 0 0 0 0 0 0 0 
260	0 0 0 0 0 0 0 0 0 0 
270	0 0 0 0 0 0 0 0 0 0 
280	0 0 0 0 0 0 0 0 0 0 
290	0 0 0 0 0 0 0 0 0 0 
300	0 0 0 0 0 0 0 0 0 0 
310	0 0 0 0 0 0 0 0 0 0 
320	0 0 0 0 0 0 0 0 0 0 
330	0 0 0 0 0 0 0 0 0 0 
340	0 0 0 0 0 0 0 0 0 0 
350	0 0 0 0 0 0 0 0 0 0 
360	0 0 0 0 0 0 0 0 0 0 
370	0 0 0 0 0 0 0 0 0 0 
380	0 0 0 0 0 0 0 0 0 0 
390	0 0 0 0 0 0 0 0 0 0 
400	0 0 0 0 0 0 0 0 0 0 
410	0 0 0 0 0 0 0 0 0 0 
420	0 0 0 0 0 0 0 0 0 0 
430	0 0 0 0 0 0 0 0 0 0 
440	0 0 0 0 0 0 0 0 0 0 
450	0 0 0 0 0 0 0 0 0 0 
460	0 0 0 0 0 0 0 0 0 0 
470	0 0 0 0 0 0 0 0 0 0 
480	0 0 0 0 0 0 0 0 0 0 
490	0 0 0 0 0 0 0 0 0 0 
500	0 0 0 0 0 0 0 0 0 0 
510	0 0 0 0 0 0 0 0 0 0 
520	0 0 0 0 0 0 0 0 0 0 
530	0 0 0 0 0 0 0 0 0 0 
540	0 0 0 0 0 0 0 0 0 0 
550	0 0 0 0 0 0 0 0 0 0 
560	0 0 0 0 0 0 0 0 0 0 
570	0 0 0 0 0 0 0 0 0 0 
580	0 0 0 0 0 0 0 0 0 0 
590	0 0 0 0 0 0 0 0 0 0 
600	0 0 0 0 0 0 0 0 0 0 
610	0 0 0 0 0 0 0 0 0 0 
620	0 0 0 0 0 0 0 0 0 0 
630	0 0 0 0 0 0 0 0 0 0 
640	0 0 0 0 0 0 0 0 0 0 
650	0 0 0 0 0 0 0 0 0 0 
660	0 0 0 0 0 0 0 0 0 0 
670	0 0 0 0 0 0 0 0 0 0 
680	0 0 0 0 0 0 0 0 0 0 
690	0 0 0 0 0 0 0 0 0 0 
700	0 0 0 0 0 0 0 0 0 0 
710	0 0 0 0 0 0 0 0 0 0 
720	0 0 0 0 0 0 0 0 0 0 
730	0 0 0 0 0 0 0 0 0 0 
740	0 0 0 0 0 0 0 0 0 0 
750	0 0 0 0 0 0 0 0 0 0 
760	0 0 0 0 0 0 0 0 0 0 
770	0 0 0 0 0 0 0 0 0 0 
780	0 0 0 0 0 0 0 0 0 0 
790	0 0 0 0 0 0 0 0 0 0 
800	0 0 0 0 0 0 0 0 0 0 
810	0 0 0 0 0 0 0 0 0 0 
820	0 0 0 0 0 0 0 0 0 0 
830	0 0 0 0 0 0 0 0 0 0 
840	0 0 0 0 0 0 0 0 0 0 
850	0 0 0 0 0 0 0 0 0 0 
860	0 0 0 0 0 0 0 0 0 0 
870	0 0 0 0 0 0 0 0 0 0 
880	0 0 0 0 0 0 0 0 0 0 
890	0 0 0 0 0 0 0 0 0 0 
900	0 0 0 0 0 0 0 0 0 0 
910	0 0 0 0 0 0 0 0 0 0 
920	0 0 0 0 0 0 0 0 0 0 
930	0 0 0 0 0 0 0 0 0 0 
940	0 0 0 0 0 0 0 0 0 0 
950	0 0 0 0 0 0 0 0 0 0 
960	0 0 0 0 0 0 0 0 0 0 
970	0 0 0 0 0 0 0 0 0 0 
980	0 0 0 0 0 0 0 0 0 0 
990	0 0 0 0 0 0 0 0 0 0 
-----------------------------------
Proc 3
0	1000 11 0 5 0 1 350 380 0 2 
10	0 0 0 0 0 0 0 0 0 0 
20	0 0 0 0 0 0 0 0 0 0 
30	0 0 0 0 0 0 0 0 0 0 
40	0 0 0 0 0 0 0 0 0 0 
50	0 0 0 0 0 0 0 0 0 0 
60	0 0 0 0 0 0 0 0 0 0 
70	0 0 0 0 0 0 0 0 0 0 
80	0 0 0 0 0 0 0 0 0 0 
90	0 0 0 0 0 0 0 0 0 0 
100	0 0 0 0 0 0 0 0 0 0 
110	0 0 0 0 0 0 0 0 0 0 
120	0 0 0 0 0 0 0 0 0 0 
130	0 0 0 0 0 0 0 0 0 0 
140	0 0 0 0 0 0 0 0 0 0 
150	0 0 0 0 0 0 0 0 0 0 
160	0 0 0 0 0 0 0 0 0 0 
170	0 0 0 0 0 0 0 0 0 0 
180	0 0 0 0 0 0 0 0 0 0 
190	0 0 0 0 0 0 0 0 0 0 
200	0 0 0 0 0 0 0 0 0 0 
210	0 0 0 0 0 0 0 0 0 0 
220	0 0 0 0 0 0 0 0 0 0 
230	0 0 0 0 0 0 0 0 0 0 
240	0 0 0 0 0 0 0 0 0 0 
250	0 0 0 0 0 0 0 0 0 0 
260	0 0 0 0 0 0 0 0 0 0 
270	0 0 0 0 0 0 0 0 0 0 
280	0 0 0 0 0 0 0 0 0 0 
290	0 0 0 0 0 0 0 0 0 0 
300	0 0 0 0 0 0 0 0 0 0 
310	0 0 0 0 0 0 0 0 0 0 
320	0 0 0 0 0 0 0 0 0 0 
330	0 0 0 0 0 0 0 0 0 0 
340	0 0 0 0 0 0 0 0 0 0 
350	20 0 0 0 0 0 0 0 0 0 
360	0 0 0 0 0 0 0 0 0 0 
370	0 0 0 0 0 0 0 0 0 0 
380	0 0 0 0 0 0 0 0 0 0 
390	0 0 0 0 0 0 0 0 0 0 
400	0 0 0 0 0 0 0 0 0 0 
410	0 0 0 0 0 0 0 0 0 0 
420	0 0 0 0 0 0 0 0 0 0 
430	0 0 0 0 0 0 0 0 0 0 
440	0 0 0 0 0 0 0 0 0 0 
450	0 0 0 0 0 0 0 0 0 0 
460	0 0 0 0 0 0 0 0 0 0 
470	0 0 0 0 0 0 0 0 0 0 
480	0 0 0 0 0 0 0 0 0 0 
490	0 0 0 0 0 0 0 0 0 0 
500	0 0 0 0 0 0 0 0 0 0 
510	0 0 0 0 0 0 0 0 0 0 
520	0 0 0 0 0 0 0 0 0 0 
530	0 0 0 0 0 0 0 0 0 0 
540	0 0 0 0 0 0 0 0 0 0 
550	0 0 0 0 0 0 0 0 0 0 
560	0 0 0 0 0 0 0 0 0 0 
570	0 0 0 0 0 0 0 0 0 0 
580	0 0 0 0 0 0 0 0 0 0 
590	0 0 0 0 0 0 0 0 0 0 
600	0 0 0 0 0 0 0 0 0 0 
610	0 0 0 0 0 0 0 0 0 0 
620	0 0 0 0 0 0 0 0 0 0 
630	0 0 0 0 0 0 0 0 0 0 
640	0 0 0 0 0 0 0 0 0 0 
650	0 0 0 0 0 0 0 0 0 0 
660	0 0 0 0 0 0 0 0 0 0 
670	0 0 0 0 0 0 0 0 0 0 
680	0 0 0 0 0 0 0 0 0 0 
690	0 0 0 0 0 0 0 0 0 0 
700	0 0 0 0 0 0 0 0 0 0 
710	0 0 0 0 0 0 0 0 0 0 
720	0 0 0 0 0 0 0 0 0 0 
730	0 0 0 0 0 0 0 0 0 0 
740	0 0 0 0 0 0 0 0 0 0 
750	0 0 0 0 0 0 0 0 0 0 
760	0 0 0 0 0 0 0 0 0 0 
770	0 0 0 0 0 0 0 0 0 0 
780	0 0 0 0 0 0 0 0 0 0 
790	0 0 0 0 0 0 0 0 0 0 
800	0 0 0 0 0 0 0 0 0 0 
810	0 0 0 0 0 0 0 0 0 0 
820	0 0 0 0 0 0 0 0 0 0 
830	0 0 0 0 0 0 0 0 0 0 
840	0 0 0 0 0 0 0 0 0 0 
850	0 0 0 0 0 0 0 0 0 0 
860	0 0 0 0 0 0 0 0 0 0 
870	0 0 0 0 0 0 0 0 0 0 
880	0 0 0 0 0 0 0 0 0 0 
890	0 0 0 0 0 0 0 0 0 0 
900	0 0 0 0 0 0 0 0 0 0 
910	0 0 0 0 0 0 0 0 0 0 
920	0 0 0 0 0 0 0 0 0 0 
930	0 0 0 0 0 0 0 0 0 0 
940	0 0 0 0 0 0 0 0 0 0 
950	0 0 0 0 0 0 0 0 0 0 
960	0 0 0 0 0 0 0 0 0 0 
970	0 0 0 0 0 0 0 0 0 0 
980	0 0 0 0 0 0 0 0 0 0 
990	0 0 0 0 0 0 0 0 0 0 
-----------------------------------
